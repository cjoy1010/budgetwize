
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model credit_cards
 * 
 */
export type credit_cards = $Result.DefaultSelection<Prisma.$credit_cardsPayload>
/**
 * Model payment_plan
 * 
 */
export type payment_plan = $Result.DefaultSelection<Prisma.$payment_planPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model plaidtransaction
 * 
 */
export type plaidtransaction = $Result.DefaultSelection<Prisma.$plaidtransactionPayload>
/**
 * Model security_log
 * 
 */
export type security_log = $Result.DefaultSelection<Prisma.$security_logPayload>
/**
 * Model settlements
 * 
 */
export type settlements = $Result.DefaultSelection<Prisma.$settlementsPayload>
/**
 * Model transactions
 * 
 */
export type transactions = $Result.DefaultSelection<Prisma.$transactionsPayload>
/**
 * Model user_session
 * 
 */
export type user_session = $Result.DefaultSelection<Prisma.$user_sessionPayload>
/**
 * Model userplaiditem
 * 
 */
export type userplaiditem = $Result.DefaultSelection<Prisma.$userplaiditemPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model debt_payment
 * 
 */
export type debt_payment = $Result.DefaultSelection<Prisma.$debt_paymentPayload>
/**
 * Model debt
 * 
 */
export type debt = $Result.DefaultSelection<Prisma.$debtPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const transactions_TRANS_TYPE: {
  Purchase: 'Purchase',
  Fee: 'Fee',
  Interest: 'Interest',
  Refund: 'Refund',
  Payment: 'Payment',
  Subscription: 'Subscription'
};

export type transactions_TRANS_TYPE = (typeof transactions_TRANS_TYPE)[keyof typeof transactions_TRANS_TYPE]


export const credit_cards_CARD_TYPE: {
  Visa: 'Visa',
  MasterCard: 'MasterCard',
  Amex: 'Amex',
  Discover: 'Discover'
};

export type credit_cards_CARD_TYPE = (typeof credit_cards_CARD_TYPE)[keyof typeof credit_cards_CARD_TYPE]


export const payment_plan_CHOSEN_PLAN: {
  Lowest: 'Lowest',
  Highest: 'Highest'
};

export type payment_plan_CHOSEN_PLAN = (typeof payment_plan_CHOSEN_PLAN)[keyof typeof payment_plan_CHOSEN_PLAN]


export const payments_PAYMENT_METHOD: {
  Transfer: 'Transfer',
  Check: 'Check',
  Credit: 'Credit',
  Cash: 'Cash',
  ACH: 'ACH'
};

export type payments_PAYMENT_METHOD = (typeof payments_PAYMENT_METHOD)[keyof typeof payments_PAYMENT_METHOD]


export const settlements_STATUS: {
  Pending: 'Pending',
  Completed: 'Completed',
  Rejected: 'Rejected'
};

export type settlements_STATUS = (typeof settlements_STATUS)[keyof typeof settlements_STATUS]


export const payments_STATUS: {
  Pending: 'Pending',
  Completed: 'Completed',
  Failed: 'Failed'
};

export type payments_STATUS = (typeof payments_STATUS)[keyof typeof payments_STATUS]


export const credit_cards_STATUS: {
  Active: 'Active',
  Blocked: 'Blocked',
  Closed: 'Closed'
};

export type credit_cards_STATUS = (typeof credit_cards_STATUS)[keyof typeof credit_cards_STATUS]

}

export type transactions_TRANS_TYPE = $Enums.transactions_TRANS_TYPE

export const transactions_TRANS_TYPE: typeof $Enums.transactions_TRANS_TYPE

export type credit_cards_CARD_TYPE = $Enums.credit_cards_CARD_TYPE

export const credit_cards_CARD_TYPE: typeof $Enums.credit_cards_CARD_TYPE

export type payment_plan_CHOSEN_PLAN = $Enums.payment_plan_CHOSEN_PLAN

export const payment_plan_CHOSEN_PLAN: typeof $Enums.payment_plan_CHOSEN_PLAN

export type payments_PAYMENT_METHOD = $Enums.payments_PAYMENT_METHOD

export const payments_PAYMENT_METHOD: typeof $Enums.payments_PAYMENT_METHOD

export type settlements_STATUS = $Enums.settlements_STATUS

export const settlements_STATUS: typeof $Enums.settlements_STATUS

export type payments_STATUS = $Enums.payments_STATUS

export const payments_STATUS: typeof $Enums.payments_STATUS

export type credit_cards_STATUS = $Enums.credit_cards_STATUS

export const credit_cards_STATUS: typeof $Enums.credit_cards_STATUS

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Credit_cards
 * const credit_cards = await prisma.credit_cards.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Credit_cards
   * const credit_cards = await prisma.credit_cards.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.credit_cards`: Exposes CRUD operations for the **credit_cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credit_cards
    * const credit_cards = await prisma.credit_cards.findMany()
    * ```
    */
  get credit_cards(): Prisma.credit_cardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_plan`: Exposes CRUD operations for the **payment_plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_plans
    * const payment_plans = await prisma.payment_plan.findMany()
    * ```
    */
  get payment_plan(): Prisma.payment_planDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plaidtransaction`: Exposes CRUD operations for the **plaidtransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plaidtransactions
    * const plaidtransactions = await prisma.plaidtransaction.findMany()
    * ```
    */
  get plaidtransaction(): Prisma.plaidtransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.security_log`: Exposes CRUD operations for the **security_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Security_logs
    * const security_logs = await prisma.security_log.findMany()
    * ```
    */
  get security_log(): Prisma.security_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settlements`: Exposes CRUD operations for the **settlements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settlements
    * const settlements = await prisma.settlements.findMany()
    * ```
    */
  get settlements(): Prisma.settlementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_session`: Exposes CRUD operations for the **user_session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_sessions
    * const user_sessions = await prisma.user_session.findMany()
    * ```
    */
  get user_session(): Prisma.user_sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userplaiditem`: Exposes CRUD operations for the **userplaiditem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userplaiditems
    * const userplaiditems = await prisma.userplaiditem.findMany()
    * ```
    */
  get userplaiditem(): Prisma.userplaiditemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debt_payment`: Exposes CRUD operations for the **debt_payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debt_payments
    * const debt_payments = await prisma.debt_payment.findMany()
    * ```
    */
  get debt_payment(): Prisma.debt_paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debt`: Exposes CRUD operations for the **debt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debts
    * const debts = await prisma.debt.findMany()
    * ```
    */
  get debt(): Prisma.debtDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    credit_cards: 'credit_cards',
    payment_plan: 'payment_plan',
    payments: 'payments',
    plaidtransaction: 'plaidtransaction',
    security_log: 'security_log',
    settlements: 'settlements',
    transactions: 'transactions',
    user_session: 'user_session',
    userplaiditem: 'userplaiditem',
    users: 'users',
    debt_payment: 'debt_payment',
    debt: 'debt'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "credit_cards" | "payment_plan" | "payments" | "plaidtransaction" | "security_log" | "settlements" | "transactions" | "user_session" | "userplaiditem" | "users" | "debt_payment" | "debt"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      credit_cards: {
        payload: Prisma.$credit_cardsPayload<ExtArgs>
        fields: Prisma.credit_cardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.credit_cardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.credit_cardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          findFirst: {
            args: Prisma.credit_cardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.credit_cardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          findMany: {
            args: Prisma.credit_cardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>[]
          }
          create: {
            args: Prisma.credit_cardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          createMany: {
            args: Prisma.credit_cardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.credit_cardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          update: {
            args: Prisma.credit_cardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          deleteMany: {
            args: Prisma.credit_cardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.credit_cardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.credit_cardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          aggregate: {
            args: Prisma.Credit_cardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredit_cards>
          }
          groupBy: {
            args: Prisma.credit_cardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Credit_cardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.credit_cardsCountArgs<ExtArgs>
            result: $Utils.Optional<Credit_cardsCountAggregateOutputType> | number
          }
        }
      }
      payment_plan: {
        payload: Prisma.$payment_planPayload<ExtArgs>
        fields: Prisma.payment_planFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_planFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_planFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload>
          }
          findFirst: {
            args: Prisma.payment_planFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_planFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload>
          }
          findMany: {
            args: Prisma.payment_planFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload>[]
          }
          create: {
            args: Prisma.payment_planCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload>
          }
          createMany: {
            args: Prisma.payment_planCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.payment_planDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload>
          }
          update: {
            args: Prisma.payment_planUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload>
          }
          deleteMany: {
            args: Prisma.payment_planDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_planUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.payment_planUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_planPayload>
          }
          aggregate: {
            args: Prisma.Payment_planAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_plan>
          }
          groupBy: {
            args: Prisma.payment_planGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_planGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_planCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_planCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      plaidtransaction: {
        payload: Prisma.$plaidtransactionPayload<ExtArgs>
        fields: Prisma.plaidtransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plaidtransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plaidtransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload>
          }
          findFirst: {
            args: Prisma.plaidtransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plaidtransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload>
          }
          findMany: {
            args: Prisma.plaidtransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload>[]
          }
          create: {
            args: Prisma.plaidtransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload>
          }
          createMany: {
            args: Prisma.plaidtransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.plaidtransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload>
          }
          update: {
            args: Prisma.plaidtransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload>
          }
          deleteMany: {
            args: Prisma.plaidtransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plaidtransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.plaidtransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaidtransactionPayload>
          }
          aggregate: {
            args: Prisma.PlaidtransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaidtransaction>
          }
          groupBy: {
            args: Prisma.plaidtransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaidtransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.plaidtransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PlaidtransactionCountAggregateOutputType> | number
          }
        }
      }
      security_log: {
        payload: Prisma.$security_logPayload<ExtArgs>
        fields: Prisma.security_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.security_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.security_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload>
          }
          findFirst: {
            args: Prisma.security_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.security_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload>
          }
          findMany: {
            args: Prisma.security_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload>[]
          }
          create: {
            args: Prisma.security_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload>
          }
          createMany: {
            args: Prisma.security_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.security_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload>
          }
          update: {
            args: Prisma.security_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload>
          }
          deleteMany: {
            args: Prisma.security_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.security_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.security_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_logPayload>
          }
          aggregate: {
            args: Prisma.Security_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurity_log>
          }
          groupBy: {
            args: Prisma.security_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Security_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.security_logCountArgs<ExtArgs>
            result: $Utils.Optional<Security_logCountAggregateOutputType> | number
          }
        }
      }
      settlements: {
        payload: Prisma.$settlementsPayload<ExtArgs>
        fields: Prisma.settlementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settlementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settlementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload>
          }
          findFirst: {
            args: Prisma.settlementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settlementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload>
          }
          findMany: {
            args: Prisma.settlementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload>[]
          }
          create: {
            args: Prisma.settlementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload>
          }
          createMany: {
            args: Prisma.settlementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.settlementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload>
          }
          update: {
            args: Prisma.settlementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload>
          }
          deleteMany: {
            args: Prisma.settlementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settlementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.settlementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlementsPayload>
          }
          aggregate: {
            args: Prisma.SettlementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettlements>
          }
          groupBy: {
            args: Prisma.settlementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettlementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.settlementsCountArgs<ExtArgs>
            result: $Utils.Optional<SettlementsCountAggregateOutputType> | number
          }
        }
      }
      transactions: {
        payload: Prisma.$transactionsPayload<ExtArgs>
        fields: Prisma.transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findFirst: {
            args: Prisma.transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findMany: {
            args: Prisma.transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          create: {
            args: Prisma.transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          createMany: {
            args: Prisma.transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          update: {
            args: Prisma.transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          deleteMany: {
            args: Prisma.transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      user_session: {
        payload: Prisma.$user_sessionPayload<ExtArgs>
        fields: Prisma.user_sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload>
          }
          findFirst: {
            args: Prisma.user_sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload>
          }
          findMany: {
            args: Prisma.user_sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload>[]
          }
          create: {
            args: Prisma.user_sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload>
          }
          createMany: {
            args: Prisma.user_sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload>
          }
          update: {
            args: Prisma.user_sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload>
          }
          deleteMany: {
            args: Prisma.user_sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionPayload>
          }
          aggregate: {
            args: Prisma.User_sessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_session>
          }
          groupBy: {
            args: Prisma.user_sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_sessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_sessionCountArgs<ExtArgs>
            result: $Utils.Optional<User_sessionCountAggregateOutputType> | number
          }
        }
      }
      userplaiditem: {
        payload: Prisma.$userplaiditemPayload<ExtArgs>
        fields: Prisma.userplaiditemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userplaiditemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userplaiditemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload>
          }
          findFirst: {
            args: Prisma.userplaiditemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userplaiditemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload>
          }
          findMany: {
            args: Prisma.userplaiditemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload>[]
          }
          create: {
            args: Prisma.userplaiditemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload>
          }
          createMany: {
            args: Prisma.userplaiditemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userplaiditemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload>
          }
          update: {
            args: Prisma.userplaiditemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload>
          }
          deleteMany: {
            args: Prisma.userplaiditemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userplaiditemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userplaiditemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userplaiditemPayload>
          }
          aggregate: {
            args: Prisma.UserplaiditemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserplaiditem>
          }
          groupBy: {
            args: Prisma.userplaiditemGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserplaiditemGroupByOutputType>[]
          }
          count: {
            args: Prisma.userplaiditemCountArgs<ExtArgs>
            result: $Utils.Optional<UserplaiditemCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      debt_payment: {
        payload: Prisma.$debt_paymentPayload<ExtArgs>
        fields: Prisma.debt_paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.debt_paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.debt_paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload>
          }
          findFirst: {
            args: Prisma.debt_paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.debt_paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload>
          }
          findMany: {
            args: Prisma.debt_paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload>[]
          }
          create: {
            args: Prisma.debt_paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload>
          }
          createMany: {
            args: Prisma.debt_paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.debt_paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload>
          }
          update: {
            args: Prisma.debt_paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload>
          }
          deleteMany: {
            args: Prisma.debt_paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.debt_paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.debt_paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debt_paymentPayload>
          }
          aggregate: {
            args: Prisma.Debt_paymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebt_payment>
          }
          groupBy: {
            args: Prisma.debt_paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Debt_paymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.debt_paymentCountArgs<ExtArgs>
            result: $Utils.Optional<Debt_paymentCountAggregateOutputType> | number
          }
        }
      }
      debt: {
        payload: Prisma.$debtPayload<ExtArgs>
        fields: Prisma.debtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.debtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.debtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload>
          }
          findFirst: {
            args: Prisma.debtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.debtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload>
          }
          findMany: {
            args: Prisma.debtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload>[]
          }
          create: {
            args: Prisma.debtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload>
          }
          createMany: {
            args: Prisma.debtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.debtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload>
          }
          update: {
            args: Prisma.debtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload>
          }
          deleteMany: {
            args: Prisma.debtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.debtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.debtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$debtPayload>
          }
          aggregate: {
            args: Prisma.DebtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebt>
          }
          groupBy: {
            args: Prisma.debtGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtGroupByOutputType>[]
          }
          count: {
            args: Prisma.debtCountArgs<ExtArgs>
            result: $Utils.Optional<DebtCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    credit_cards?: credit_cardsOmit
    payment_plan?: payment_planOmit
    payments?: paymentsOmit
    plaidtransaction?: plaidtransactionOmit
    security_log?: security_logOmit
    settlements?: settlementsOmit
    transactions?: transactionsOmit
    user_session?: user_sessionOmit
    userplaiditem?: userplaiditemOmit
    users?: usersOmit
    debt_payment?: debt_paymentOmit
    debt?: debtOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Credit_cardsCountOutputType
   */

  export type Credit_cardsCountOutputType = {
    payment_plan: number
    payments: number
    settlements: number
    transactions: number
  }

  export type Credit_cardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_plan?: boolean | Credit_cardsCountOutputTypeCountPayment_planArgs
    payments?: boolean | Credit_cardsCountOutputTypeCountPaymentsArgs
    settlements?: boolean | Credit_cardsCountOutputTypeCountSettlementsArgs
    transactions?: boolean | Credit_cardsCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * Credit_cardsCountOutputType without action
   */
  export type Credit_cardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit_cardsCountOutputType
     */
    select?: Credit_cardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Credit_cardsCountOutputType without action
   */
  export type Credit_cardsCountOutputTypeCountPayment_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_planWhereInput
  }

  /**
   * Credit_cardsCountOutputType without action
   */
  export type Credit_cardsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * Credit_cardsCountOutputType without action
   */
  export type Credit_cardsCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settlementsWhereInput
  }

  /**
   * Credit_cardsCountOutputType without action
   */
  export type Credit_cardsCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    credit_cards: number
    payment_plan: number
    payments: number
    security_log: number
    settlements: number
    user_session: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_cards?: boolean | UsersCountOutputTypeCountCredit_cardsArgs
    payment_plan?: boolean | UsersCountOutputTypeCountPayment_planArgs
    payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
    security_log?: boolean | UsersCountOutputTypeCountSecurity_logArgs
    settlements?: boolean | UsersCountOutputTypeCountSettlementsArgs
    user_session?: boolean | UsersCountOutputTypeCountUser_sessionArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCredit_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credit_cardsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPayment_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_planWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSecurity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: security_logWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settlementsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_sessionWhereInput
  }


  /**
   * Count Type DebtCountOutputType
   */

  export type DebtCountOutputType = {
    payments: number
  }

  export type DebtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | DebtCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtCountOutputType
     */
    select?: DebtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: debt_paymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model credit_cards
   */

  export type AggregateCredit_cards = {
    _count: Credit_cardsCountAggregateOutputType | null
    _avg: Credit_cardsAvgAggregateOutputType | null
    _sum: Credit_cardsSumAggregateOutputType | null
    _min: Credit_cardsMinAggregateOutputType | null
    _max: Credit_cardsMaxAggregateOutputType | null
  }

  export type Credit_cardsAvgAggregateOutputType = {
    CARD_ID: number | null
    USER_ID: number | null
    CREDIT_LIMIT: Decimal | null
    BALANCE: Decimal | null
    INTEREST_RATE: Decimal | null
  }

  export type Credit_cardsSumAggregateOutputType = {
    CARD_ID: number | null
    USER_ID: number | null
    CREDIT_LIMIT: Decimal | null
    BALANCE: Decimal | null
    INTEREST_RATE: Decimal | null
  }

  export type Credit_cardsMinAggregateOutputType = {
    CARD_ID: number | null
    USER_ID: number | null
    CARD_NUMBER: string | null
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE | null
    CREDIT_LIMIT: Decimal | null
    BALANCE: Decimal | null
    INTEREST_RATE: Decimal | null
    DUE_DATE: Date | null
    STATUS: $Enums.credit_cards_STATUS | null
  }

  export type Credit_cardsMaxAggregateOutputType = {
    CARD_ID: number | null
    USER_ID: number | null
    CARD_NUMBER: string | null
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE | null
    CREDIT_LIMIT: Decimal | null
    BALANCE: Decimal | null
    INTEREST_RATE: Decimal | null
    DUE_DATE: Date | null
    STATUS: $Enums.credit_cards_STATUS | null
  }

  export type Credit_cardsCountAggregateOutputType = {
    CARD_ID: number
    USER_ID: number
    CARD_NUMBER: number
    CARD_TYPE: number
    CREDIT_LIMIT: number
    BALANCE: number
    INTEREST_RATE: number
    DUE_DATE: number
    STATUS: number
    _all: number
  }


  export type Credit_cardsAvgAggregateInputType = {
    CARD_ID?: true
    USER_ID?: true
    CREDIT_LIMIT?: true
    BALANCE?: true
    INTEREST_RATE?: true
  }

  export type Credit_cardsSumAggregateInputType = {
    CARD_ID?: true
    USER_ID?: true
    CREDIT_LIMIT?: true
    BALANCE?: true
    INTEREST_RATE?: true
  }

  export type Credit_cardsMinAggregateInputType = {
    CARD_ID?: true
    USER_ID?: true
    CARD_NUMBER?: true
    CARD_TYPE?: true
    CREDIT_LIMIT?: true
    BALANCE?: true
    INTEREST_RATE?: true
    DUE_DATE?: true
    STATUS?: true
  }

  export type Credit_cardsMaxAggregateInputType = {
    CARD_ID?: true
    USER_ID?: true
    CARD_NUMBER?: true
    CARD_TYPE?: true
    CREDIT_LIMIT?: true
    BALANCE?: true
    INTEREST_RATE?: true
    DUE_DATE?: true
    STATUS?: true
  }

  export type Credit_cardsCountAggregateInputType = {
    CARD_ID?: true
    USER_ID?: true
    CARD_NUMBER?: true
    CARD_TYPE?: true
    CREDIT_LIMIT?: true
    BALANCE?: true
    INTEREST_RATE?: true
    DUE_DATE?: true
    STATUS?: true
    _all?: true
  }

  export type Credit_cardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_cards to aggregate.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credit_cards
    **/
    _count?: true | Credit_cardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Credit_cardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Credit_cardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Credit_cardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Credit_cardsMaxAggregateInputType
  }

  export type GetCredit_cardsAggregateType<T extends Credit_cardsAggregateArgs> = {
        [P in keyof T & keyof AggregateCredit_cards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredit_cards[P]>
      : GetScalarType<T[P], AggregateCredit_cards[P]>
  }




  export type credit_cardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credit_cardsWhereInput
    orderBy?: credit_cardsOrderByWithAggregationInput | credit_cardsOrderByWithAggregationInput[]
    by: Credit_cardsScalarFieldEnum[] | Credit_cardsScalarFieldEnum
    having?: credit_cardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Credit_cardsCountAggregateInputType | true
    _avg?: Credit_cardsAvgAggregateInputType
    _sum?: Credit_cardsSumAggregateInputType
    _min?: Credit_cardsMinAggregateInputType
    _max?: Credit_cardsMaxAggregateInputType
  }

  export type Credit_cardsGroupByOutputType = {
    CARD_ID: number
    USER_ID: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal
    BALANCE: Decimal | null
    INTEREST_RATE: Decimal | null
    DUE_DATE: Date
    STATUS: $Enums.credit_cards_STATUS | null
    _count: Credit_cardsCountAggregateOutputType | null
    _avg: Credit_cardsAvgAggregateOutputType | null
    _sum: Credit_cardsSumAggregateOutputType | null
    _min: Credit_cardsMinAggregateOutputType | null
    _max: Credit_cardsMaxAggregateOutputType | null
  }

  type GetCredit_cardsGroupByPayload<T extends credit_cardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Credit_cardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Credit_cardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Credit_cardsGroupByOutputType[P]>
            : GetScalarType<T[P], Credit_cardsGroupByOutputType[P]>
        }
      >
    >


  export type credit_cardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CARD_ID?: boolean
    USER_ID?: boolean
    CARD_NUMBER?: boolean
    CARD_TYPE?: boolean
    CREDIT_LIMIT?: boolean
    BALANCE?: boolean
    INTEREST_RATE?: boolean
    DUE_DATE?: boolean
    STATUS?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    payment_plan?: boolean | credit_cards$payment_planArgs<ExtArgs>
    payments?: boolean | credit_cards$paymentsArgs<ExtArgs>
    settlements?: boolean | credit_cards$settlementsArgs<ExtArgs>
    transactions?: boolean | credit_cards$transactionsArgs<ExtArgs>
    _count?: boolean | Credit_cardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credit_cards"]>



  export type credit_cardsSelectScalar = {
    CARD_ID?: boolean
    USER_ID?: boolean
    CARD_NUMBER?: boolean
    CARD_TYPE?: boolean
    CREDIT_LIMIT?: boolean
    BALANCE?: boolean
    INTEREST_RATE?: boolean
    DUE_DATE?: boolean
    STATUS?: boolean
  }

  export type credit_cardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"CARD_ID" | "USER_ID" | "CARD_NUMBER" | "CARD_TYPE" | "CREDIT_LIMIT" | "BALANCE" | "INTEREST_RATE" | "DUE_DATE" | "STATUS", ExtArgs["result"]["credit_cards"]>
  export type credit_cardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    payment_plan?: boolean | credit_cards$payment_planArgs<ExtArgs>
    payments?: boolean | credit_cards$paymentsArgs<ExtArgs>
    settlements?: boolean | credit_cards$settlementsArgs<ExtArgs>
    transactions?: boolean | credit_cards$transactionsArgs<ExtArgs>
    _count?: boolean | Credit_cardsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $credit_cardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credit_cards"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      payment_plan: Prisma.$payment_planPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      settlements: Prisma.$settlementsPayload<ExtArgs>[]
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      CARD_ID: number
      USER_ID: number
      CARD_NUMBER: string
      CARD_TYPE: $Enums.credit_cards_CARD_TYPE
      CREDIT_LIMIT: Prisma.Decimal
      BALANCE: Prisma.Decimal | null
      INTEREST_RATE: Prisma.Decimal | null
      DUE_DATE: Date
      STATUS: $Enums.credit_cards_STATUS | null
    }, ExtArgs["result"]["credit_cards"]>
    composites: {}
  }

  type credit_cardsGetPayload<S extends boolean | null | undefined | credit_cardsDefaultArgs> = $Result.GetResult<Prisma.$credit_cardsPayload, S>

  type credit_cardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<credit_cardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Credit_cardsCountAggregateInputType | true
    }

  export interface credit_cardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credit_cards'], meta: { name: 'credit_cards' } }
    /**
     * Find zero or one Credit_cards that matches the filter.
     * @param {credit_cardsFindUniqueArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends credit_cardsFindUniqueArgs>(args: SelectSubset<T, credit_cardsFindUniqueArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credit_cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {credit_cardsFindUniqueOrThrowArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends credit_cardsFindUniqueOrThrowArgs>(args: SelectSubset<T, credit_cardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsFindFirstArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends credit_cardsFindFirstArgs>(args?: SelectSubset<T, credit_cardsFindFirstArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit_cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsFindFirstOrThrowArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends credit_cardsFindFirstOrThrowArgs>(args?: SelectSubset<T, credit_cardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credit_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credit_cards
     * const credit_cards = await prisma.credit_cards.findMany()
     * 
     * // Get first 10 Credit_cards
     * const credit_cards = await prisma.credit_cards.findMany({ take: 10 })
     * 
     * // Only select the `CARD_ID`
     * const credit_cardsWithCARD_IDOnly = await prisma.credit_cards.findMany({ select: { CARD_ID: true } })
     * 
     */
    findMany<T extends credit_cardsFindManyArgs>(args?: SelectSubset<T, credit_cardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credit_cards.
     * @param {credit_cardsCreateArgs} args - Arguments to create a Credit_cards.
     * @example
     * // Create one Credit_cards
     * const Credit_cards = await prisma.credit_cards.create({
     *   data: {
     *     // ... data to create a Credit_cards
     *   }
     * })
     * 
     */
    create<T extends credit_cardsCreateArgs>(args: SelectSubset<T, credit_cardsCreateArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credit_cards.
     * @param {credit_cardsCreateManyArgs} args - Arguments to create many Credit_cards.
     * @example
     * // Create many Credit_cards
     * const credit_cards = await prisma.credit_cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends credit_cardsCreateManyArgs>(args?: SelectSubset<T, credit_cardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Credit_cards.
     * @param {credit_cardsDeleteArgs} args - Arguments to delete one Credit_cards.
     * @example
     * // Delete one Credit_cards
     * const Credit_cards = await prisma.credit_cards.delete({
     *   where: {
     *     // ... filter to delete one Credit_cards
     *   }
     * })
     * 
     */
    delete<T extends credit_cardsDeleteArgs>(args: SelectSubset<T, credit_cardsDeleteArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credit_cards.
     * @param {credit_cardsUpdateArgs} args - Arguments to update one Credit_cards.
     * @example
     * // Update one Credit_cards
     * const credit_cards = await prisma.credit_cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends credit_cardsUpdateArgs>(args: SelectSubset<T, credit_cardsUpdateArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credit_cards.
     * @param {credit_cardsDeleteManyArgs} args - Arguments to filter Credit_cards to delete.
     * @example
     * // Delete a few Credit_cards
     * const { count } = await prisma.credit_cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends credit_cardsDeleteManyArgs>(args?: SelectSubset<T, credit_cardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credit_cards
     * const credit_cards = await prisma.credit_cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends credit_cardsUpdateManyArgs>(args: SelectSubset<T, credit_cardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credit_cards.
     * @param {credit_cardsUpsertArgs} args - Arguments to update or create a Credit_cards.
     * @example
     * // Update or create a Credit_cards
     * const credit_cards = await prisma.credit_cards.upsert({
     *   create: {
     *     // ... data to create a Credit_cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credit_cards we want to update
     *   }
     * })
     */
    upsert<T extends credit_cardsUpsertArgs>(args: SelectSubset<T, credit_cardsUpsertArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsCountArgs} args - Arguments to filter Credit_cards to count.
     * @example
     * // Count the number of Credit_cards
     * const count = await prisma.credit_cards.count({
     *   where: {
     *     // ... the filter for the Credit_cards we want to count
     *   }
     * })
    **/
    count<T extends credit_cardsCountArgs>(
      args?: Subset<T, credit_cardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Credit_cardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Credit_cardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Credit_cardsAggregateArgs>(args: Subset<T, Credit_cardsAggregateArgs>): Prisma.PrismaPromise<GetCredit_cardsAggregateType<T>>

    /**
     * Group by Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends credit_cardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: credit_cardsGroupByArgs['orderBy'] }
        : { orderBy?: credit_cardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, credit_cardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredit_cardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credit_cards model
   */
  readonly fields: credit_cardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credit_cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__credit_cardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment_plan<T extends credit_cards$payment_planArgs<ExtArgs> = {}>(args?: Subset<T, credit_cards$payment_planArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends credit_cards$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, credit_cards$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settlements<T extends credit_cards$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, credit_cards$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends credit_cards$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, credit_cards$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credit_cards model
   */
  interface credit_cardsFieldRefs {
    readonly CARD_ID: FieldRef<"credit_cards", 'Int'>
    readonly USER_ID: FieldRef<"credit_cards", 'Int'>
    readonly CARD_NUMBER: FieldRef<"credit_cards", 'String'>
    readonly CARD_TYPE: FieldRef<"credit_cards", 'credit_cards_CARD_TYPE'>
    readonly CREDIT_LIMIT: FieldRef<"credit_cards", 'Decimal'>
    readonly BALANCE: FieldRef<"credit_cards", 'Decimal'>
    readonly INTEREST_RATE: FieldRef<"credit_cards", 'Decimal'>
    readonly DUE_DATE: FieldRef<"credit_cards", 'DateTime'>
    readonly STATUS: FieldRef<"credit_cards", 'credit_cards_STATUS'>
  }
    

  // Custom InputTypes
  /**
   * credit_cards findUnique
   */
  export type credit_cardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards findUniqueOrThrow
   */
  export type credit_cardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards findFirst
   */
  export type credit_cardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_cards.
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_cards.
     */
    distinct?: Credit_cardsScalarFieldEnum | Credit_cardsScalarFieldEnum[]
  }

  /**
   * credit_cards findFirstOrThrow
   */
  export type credit_cardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_cards.
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_cards.
     */
    distinct?: Credit_cardsScalarFieldEnum | Credit_cardsScalarFieldEnum[]
  }

  /**
   * credit_cards findMany
   */
  export type credit_cardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credit_cards.
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    distinct?: Credit_cardsScalarFieldEnum | Credit_cardsScalarFieldEnum[]
  }

  /**
   * credit_cards create
   */
  export type credit_cardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * The data needed to create a credit_cards.
     */
    data: XOR<credit_cardsCreateInput, credit_cardsUncheckedCreateInput>
  }

  /**
   * credit_cards createMany
   */
  export type credit_cardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credit_cards.
     */
    data: credit_cardsCreateManyInput | credit_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credit_cards update
   */
  export type credit_cardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * The data needed to update a credit_cards.
     */
    data: XOR<credit_cardsUpdateInput, credit_cardsUncheckedUpdateInput>
    /**
     * Choose, which credit_cards to update.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards updateMany
   */
  export type credit_cardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credit_cards.
     */
    data: XOR<credit_cardsUpdateManyMutationInput, credit_cardsUncheckedUpdateManyInput>
    /**
     * Filter which credit_cards to update
     */
    where?: credit_cardsWhereInput
    /**
     * Limit how many credit_cards to update.
     */
    limit?: number
  }

  /**
   * credit_cards upsert
   */
  export type credit_cardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * The filter to search for the credit_cards to update in case it exists.
     */
    where: credit_cardsWhereUniqueInput
    /**
     * In case the credit_cards found by the `where` argument doesn't exist, create a new credit_cards with this data.
     */
    create: XOR<credit_cardsCreateInput, credit_cardsUncheckedCreateInput>
    /**
     * In case the credit_cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credit_cardsUpdateInput, credit_cardsUncheckedUpdateInput>
  }

  /**
   * credit_cards delete
   */
  export type credit_cardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    /**
     * Filter which credit_cards to delete.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards deleteMany
   */
  export type credit_cardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_cards to delete
     */
    where?: credit_cardsWhereInput
    /**
     * Limit how many credit_cards to delete.
     */
    limit?: number
  }

  /**
   * credit_cards.payment_plan
   */
  export type credit_cards$payment_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    where?: payment_planWhereInput
    orderBy?: payment_planOrderByWithRelationInput | payment_planOrderByWithRelationInput[]
    cursor?: payment_planWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_planScalarFieldEnum | Payment_planScalarFieldEnum[]
  }

  /**
   * credit_cards.payments
   */
  export type credit_cards$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * credit_cards.settlements
   */
  export type credit_cards$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    where?: settlementsWhereInput
    orderBy?: settlementsOrderByWithRelationInput | settlementsOrderByWithRelationInput[]
    cursor?: settlementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettlementsScalarFieldEnum | SettlementsScalarFieldEnum[]
  }

  /**
   * credit_cards.transactions
   */
  export type credit_cards$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * credit_cards without action
   */
  export type credit_cardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
  }


  /**
   * Model payment_plan
   */

  export type AggregatePayment_plan = {
    _count: Payment_planCountAggregateOutputType | null
    _avg: Payment_planAvgAggregateOutputType | null
    _sum: Payment_planSumAggregateOutputType | null
    _min: Payment_planMinAggregateOutputType | null
    _max: Payment_planMaxAggregateOutputType | null
  }

  export type Payment_planAvgAggregateOutputType = {
    PLAN_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    PROGRESS: number | null
  }

  export type Payment_planSumAggregateOutputType = {
    PLAN_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    PROGRESS: number | null
  }

  export type Payment_planMinAggregateOutputType = {
    PLAN_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    CHOSEN_PLAN: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number | null
    PLAN_START: Date | null
    EST_PLAN_FINISH: Date | null
  }

  export type Payment_planMaxAggregateOutputType = {
    PLAN_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    CHOSEN_PLAN: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number | null
    PLAN_START: Date | null
    EST_PLAN_FINISH: Date | null
  }

  export type Payment_planCountAggregateOutputType = {
    PLAN_ID: number
    USER_ID: number
    CARD_ID: number
    CHOSEN_PLAN: number
    PROGRESS: number
    PLAN_START: number
    EST_PLAN_FINISH: number
    _all: number
  }


  export type Payment_planAvgAggregateInputType = {
    PLAN_ID?: true
    USER_ID?: true
    CARD_ID?: true
    PROGRESS?: true
  }

  export type Payment_planSumAggregateInputType = {
    PLAN_ID?: true
    USER_ID?: true
    CARD_ID?: true
    PROGRESS?: true
  }

  export type Payment_planMinAggregateInputType = {
    PLAN_ID?: true
    USER_ID?: true
    CARD_ID?: true
    CHOSEN_PLAN?: true
    PROGRESS?: true
    PLAN_START?: true
    EST_PLAN_FINISH?: true
  }

  export type Payment_planMaxAggregateInputType = {
    PLAN_ID?: true
    USER_ID?: true
    CARD_ID?: true
    CHOSEN_PLAN?: true
    PROGRESS?: true
    PLAN_START?: true
    EST_PLAN_FINISH?: true
  }

  export type Payment_planCountAggregateInputType = {
    PLAN_ID?: true
    USER_ID?: true
    CARD_ID?: true
    CHOSEN_PLAN?: true
    PROGRESS?: true
    PLAN_START?: true
    EST_PLAN_FINISH?: true
    _all?: true
  }

  export type Payment_planAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_plan to aggregate.
     */
    where?: payment_planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_plans to fetch.
     */
    orderBy?: payment_planOrderByWithRelationInput | payment_planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_plans
    **/
    _count?: true | Payment_planCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_planAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_planSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_planMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_planMaxAggregateInputType
  }

  export type GetPayment_planAggregateType<T extends Payment_planAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_plan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_plan[P]>
      : GetScalarType<T[P], AggregatePayment_plan[P]>
  }




  export type payment_planGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_planWhereInput
    orderBy?: payment_planOrderByWithAggregationInput | payment_planOrderByWithAggregationInput[]
    by: Payment_planScalarFieldEnum[] | Payment_planScalarFieldEnum
    having?: payment_planScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_planCountAggregateInputType | true
    _avg?: Payment_planAvgAggregateInputType
    _sum?: Payment_planSumAggregateInputType
    _min?: Payment_planMinAggregateInputType
    _max?: Payment_planMaxAggregateInputType
  }

  export type Payment_planGroupByOutputType = {
    PLAN_ID: number
    USER_ID: number
    CARD_ID: number
    CHOSEN_PLAN: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START: Date | null
    EST_PLAN_FINISH: Date | null
    _count: Payment_planCountAggregateOutputType | null
    _avg: Payment_planAvgAggregateOutputType | null
    _sum: Payment_planSumAggregateOutputType | null
    _min: Payment_planMinAggregateOutputType | null
    _max: Payment_planMaxAggregateOutputType | null
  }

  type GetPayment_planGroupByPayload<T extends payment_planGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_planGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_planGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_planGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_planGroupByOutputType[P]>
        }
      >
    >


  export type payment_planSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PLAN_ID?: boolean
    USER_ID?: boolean
    CARD_ID?: boolean
    CHOSEN_PLAN?: boolean
    PROGRESS?: boolean
    PLAN_START?: boolean
    EST_PLAN_FINISH?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    credit_cards?: boolean | credit_cardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_plan"]>



  export type payment_planSelectScalar = {
    PLAN_ID?: boolean
    USER_ID?: boolean
    CARD_ID?: boolean
    CHOSEN_PLAN?: boolean
    PROGRESS?: boolean
    PLAN_START?: boolean
    EST_PLAN_FINISH?: boolean
  }

  export type payment_planOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PLAN_ID" | "USER_ID" | "CARD_ID" | "CHOSEN_PLAN" | "PROGRESS" | "PLAN_START" | "EST_PLAN_FINISH", ExtArgs["result"]["payment_plan"]>
  export type payment_planInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    credit_cards?: boolean | credit_cardsDefaultArgs<ExtArgs>
  }

  export type $payment_planPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_plan"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      credit_cards: Prisma.$credit_cardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      PLAN_ID: number
      USER_ID: number
      CARD_ID: number
      CHOSEN_PLAN: $Enums.payment_plan_CHOSEN_PLAN | null
      PROGRESS: number
      PLAN_START: Date | null
      EST_PLAN_FINISH: Date | null
    }, ExtArgs["result"]["payment_plan"]>
    composites: {}
  }

  type payment_planGetPayload<S extends boolean | null | undefined | payment_planDefaultArgs> = $Result.GetResult<Prisma.$payment_planPayload, S>

  type payment_planCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_planFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_planCountAggregateInputType | true
    }

  export interface payment_planDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_plan'], meta: { name: 'payment_plan' } }
    /**
     * Find zero or one Payment_plan that matches the filter.
     * @param {payment_planFindUniqueArgs} args - Arguments to find a Payment_plan
     * @example
     * // Get one Payment_plan
     * const payment_plan = await prisma.payment_plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_planFindUniqueArgs>(args: SelectSubset<T, payment_planFindUniqueArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_planFindUniqueOrThrowArgs} args - Arguments to find a Payment_plan
     * @example
     * // Get one Payment_plan
     * const payment_plan = await prisma.payment_plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_planFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_planFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_planFindFirstArgs} args - Arguments to find a Payment_plan
     * @example
     * // Get one Payment_plan
     * const payment_plan = await prisma.payment_plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_planFindFirstArgs>(args?: SelectSubset<T, payment_planFindFirstArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_planFindFirstOrThrowArgs} args - Arguments to find a Payment_plan
     * @example
     * // Get one Payment_plan
     * const payment_plan = await prisma.payment_plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_planFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_planFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_planFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_plans
     * const payment_plans = await prisma.payment_plan.findMany()
     * 
     * // Get first 10 Payment_plans
     * const payment_plans = await prisma.payment_plan.findMany({ take: 10 })
     * 
     * // Only select the `PLAN_ID`
     * const payment_planWithPLAN_IDOnly = await prisma.payment_plan.findMany({ select: { PLAN_ID: true } })
     * 
     */
    findMany<T extends payment_planFindManyArgs>(args?: SelectSubset<T, payment_planFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_plan.
     * @param {payment_planCreateArgs} args - Arguments to create a Payment_plan.
     * @example
     * // Create one Payment_plan
     * const Payment_plan = await prisma.payment_plan.create({
     *   data: {
     *     // ... data to create a Payment_plan
     *   }
     * })
     * 
     */
    create<T extends payment_planCreateArgs>(args: SelectSubset<T, payment_planCreateArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_plans.
     * @param {payment_planCreateManyArgs} args - Arguments to create many Payment_plans.
     * @example
     * // Create many Payment_plans
     * const payment_plan = await prisma.payment_plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_planCreateManyArgs>(args?: SelectSubset<T, payment_planCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment_plan.
     * @param {payment_planDeleteArgs} args - Arguments to delete one Payment_plan.
     * @example
     * // Delete one Payment_plan
     * const Payment_plan = await prisma.payment_plan.delete({
     *   where: {
     *     // ... filter to delete one Payment_plan
     *   }
     * })
     * 
     */
    delete<T extends payment_planDeleteArgs>(args: SelectSubset<T, payment_planDeleteArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_plan.
     * @param {payment_planUpdateArgs} args - Arguments to update one Payment_plan.
     * @example
     * // Update one Payment_plan
     * const payment_plan = await prisma.payment_plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_planUpdateArgs>(args: SelectSubset<T, payment_planUpdateArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_plans.
     * @param {payment_planDeleteManyArgs} args - Arguments to filter Payment_plans to delete.
     * @example
     * // Delete a few Payment_plans
     * const { count } = await prisma.payment_plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_planDeleteManyArgs>(args?: SelectSubset<T, payment_planDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_planUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_plans
     * const payment_plan = await prisma.payment_plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_planUpdateManyArgs>(args: SelectSubset<T, payment_planUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment_plan.
     * @param {payment_planUpsertArgs} args - Arguments to update or create a Payment_plan.
     * @example
     * // Update or create a Payment_plan
     * const payment_plan = await prisma.payment_plan.upsert({
     *   create: {
     *     // ... data to create a Payment_plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_plan we want to update
     *   }
     * })
     */
    upsert<T extends payment_planUpsertArgs>(args: SelectSubset<T, payment_planUpsertArgs<ExtArgs>>): Prisma__payment_planClient<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_planCountArgs} args - Arguments to filter Payment_plans to count.
     * @example
     * // Count the number of Payment_plans
     * const count = await prisma.payment_plan.count({
     *   where: {
     *     // ... the filter for the Payment_plans we want to count
     *   }
     * })
    **/
    count<T extends payment_planCountArgs>(
      args?: Subset<T, payment_planCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_planCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_planAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_planAggregateArgs>(args: Subset<T, Payment_planAggregateArgs>): Prisma.PrismaPromise<GetPayment_planAggregateType<T>>

    /**
     * Group by Payment_plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_planGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_planGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_planGroupByArgs['orderBy'] }
        : { orderBy?: payment_planGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_planGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_planGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_plan model
   */
  readonly fields: payment_planFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_planClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credit_cards<T extends credit_cardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, credit_cardsDefaultArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_plan model
   */
  interface payment_planFieldRefs {
    readonly PLAN_ID: FieldRef<"payment_plan", 'Int'>
    readonly USER_ID: FieldRef<"payment_plan", 'Int'>
    readonly CARD_ID: FieldRef<"payment_plan", 'Int'>
    readonly CHOSEN_PLAN: FieldRef<"payment_plan", 'payment_plan_CHOSEN_PLAN'>
    readonly PROGRESS: FieldRef<"payment_plan", 'Int'>
    readonly PLAN_START: FieldRef<"payment_plan", 'DateTime'>
    readonly EST_PLAN_FINISH: FieldRef<"payment_plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_plan findUnique
   */
  export type payment_planFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * Filter, which payment_plan to fetch.
     */
    where: payment_planWhereUniqueInput
  }

  /**
   * payment_plan findUniqueOrThrow
   */
  export type payment_planFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * Filter, which payment_plan to fetch.
     */
    where: payment_planWhereUniqueInput
  }

  /**
   * payment_plan findFirst
   */
  export type payment_planFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * Filter, which payment_plan to fetch.
     */
    where?: payment_planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_plans to fetch.
     */
    orderBy?: payment_planOrderByWithRelationInput | payment_planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_plans.
     */
    cursor?: payment_planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_plans.
     */
    distinct?: Payment_planScalarFieldEnum | Payment_planScalarFieldEnum[]
  }

  /**
   * payment_plan findFirstOrThrow
   */
  export type payment_planFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * Filter, which payment_plan to fetch.
     */
    where?: payment_planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_plans to fetch.
     */
    orderBy?: payment_planOrderByWithRelationInput | payment_planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_plans.
     */
    cursor?: payment_planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_plans.
     */
    distinct?: Payment_planScalarFieldEnum | Payment_planScalarFieldEnum[]
  }

  /**
   * payment_plan findMany
   */
  export type payment_planFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * Filter, which payment_plans to fetch.
     */
    where?: payment_planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_plans to fetch.
     */
    orderBy?: payment_planOrderByWithRelationInput | payment_planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_plans.
     */
    cursor?: payment_planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_plans.
     */
    skip?: number
    distinct?: Payment_planScalarFieldEnum | Payment_planScalarFieldEnum[]
  }

  /**
   * payment_plan create
   */
  export type payment_planCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_plan.
     */
    data: XOR<payment_planCreateInput, payment_planUncheckedCreateInput>
  }

  /**
   * payment_plan createMany
   */
  export type payment_planCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_plans.
     */
    data: payment_planCreateManyInput | payment_planCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_plan update
   */
  export type payment_planUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_plan.
     */
    data: XOR<payment_planUpdateInput, payment_planUncheckedUpdateInput>
    /**
     * Choose, which payment_plan to update.
     */
    where: payment_planWhereUniqueInput
  }

  /**
   * payment_plan updateMany
   */
  export type payment_planUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_plans.
     */
    data: XOR<payment_planUpdateManyMutationInput, payment_planUncheckedUpdateManyInput>
    /**
     * Filter which payment_plans to update
     */
    where?: payment_planWhereInput
    /**
     * Limit how many payment_plans to update.
     */
    limit?: number
  }

  /**
   * payment_plan upsert
   */
  export type payment_planUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_plan to update in case it exists.
     */
    where: payment_planWhereUniqueInput
    /**
     * In case the payment_plan found by the `where` argument doesn't exist, create a new payment_plan with this data.
     */
    create: XOR<payment_planCreateInput, payment_planUncheckedCreateInput>
    /**
     * In case the payment_plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_planUpdateInput, payment_planUncheckedUpdateInput>
  }

  /**
   * payment_plan delete
   */
  export type payment_planDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    /**
     * Filter which payment_plan to delete.
     */
    where: payment_planWhereUniqueInput
  }

  /**
   * payment_plan deleteMany
   */
  export type payment_planDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_plans to delete
     */
    where?: payment_planWhereInput
    /**
     * Limit how many payment_plans to delete.
     */
    limit?: number
  }

  /**
   * payment_plan without action
   */
  export type payment_planDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    PAYMENT_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    PAID: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    PAYMENT_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    PAID: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    PAYMENT_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    PAID: Decimal | null
    PAYMENT_DATE: Date | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD | null
    STATUS: $Enums.payments_STATUS | null
  }

  export type PaymentsMaxAggregateOutputType = {
    PAYMENT_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    PAID: Decimal | null
    PAYMENT_DATE: Date | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD | null
    STATUS: $Enums.payments_STATUS | null
  }

  export type PaymentsCountAggregateOutputType = {
    PAYMENT_ID: number
    USER_ID: number
    CARD_ID: number
    PAID: number
    PAYMENT_DATE: number
    PAYMENT_METHOD: number
    STATUS: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    PAYMENT_ID?: true
    USER_ID?: true
    CARD_ID?: true
    PAID?: true
  }

  export type PaymentsSumAggregateInputType = {
    PAYMENT_ID?: true
    USER_ID?: true
    CARD_ID?: true
    PAID?: true
  }

  export type PaymentsMinAggregateInputType = {
    PAYMENT_ID?: true
    USER_ID?: true
    CARD_ID?: true
    PAID?: true
    PAYMENT_DATE?: true
    PAYMENT_METHOD?: true
    STATUS?: true
  }

  export type PaymentsMaxAggregateInputType = {
    PAYMENT_ID?: true
    USER_ID?: true
    CARD_ID?: true
    PAID?: true
    PAYMENT_DATE?: true
    PAYMENT_METHOD?: true
    STATUS?: true
  }

  export type PaymentsCountAggregateInputType = {
    PAYMENT_ID?: true
    USER_ID?: true
    CARD_ID?: true
    PAID?: true
    PAYMENT_DATE?: true
    PAYMENT_METHOD?: true
    STATUS?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    PAYMENT_ID: number
    USER_ID: number | null
    CARD_ID: number | null
    PAID: Decimal
    PAYMENT_DATE: Date | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS: $Enums.payments_STATUS | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PAYMENT_ID?: boolean
    USER_ID?: boolean
    CARD_ID?: boolean
    PAID?: boolean
    PAYMENT_DATE?: boolean
    PAYMENT_METHOD?: boolean
    STATUS?: boolean
    users?: boolean | payments$usersArgs<ExtArgs>
    credit_cards?: boolean | payments$credit_cardsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>



  export type paymentsSelectScalar = {
    PAYMENT_ID?: boolean
    USER_ID?: boolean
    CARD_ID?: boolean
    PAID?: boolean
    PAYMENT_DATE?: boolean
    PAYMENT_METHOD?: boolean
    STATUS?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PAYMENT_ID" | "USER_ID" | "CARD_ID" | "PAID" | "PAYMENT_DATE" | "PAYMENT_METHOD" | "STATUS", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | payments$usersArgs<ExtArgs>
    credit_cards?: boolean | payments$credit_cardsArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      credit_cards: Prisma.$credit_cardsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      PAYMENT_ID: number
      USER_ID: number | null
      CARD_ID: number | null
      PAID: Prisma.Decimal
      PAYMENT_DATE: Date | null
      PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
      STATUS: $Enums.payments_STATUS | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `PAYMENT_ID`
     * const paymentsWithPAYMENT_IDOnly = await prisma.payments.findMany({ select: { PAYMENT_ID: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends payments$usersArgs<ExtArgs> = {}>(args?: Subset<T, payments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    credit_cards<T extends payments$credit_cardsArgs<ExtArgs> = {}>(args?: Subset<T, payments$credit_cardsArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly PAYMENT_ID: FieldRef<"payments", 'Int'>
    readonly USER_ID: FieldRef<"payments", 'Int'>
    readonly CARD_ID: FieldRef<"payments", 'Int'>
    readonly PAID: FieldRef<"payments", 'Decimal'>
    readonly PAYMENT_DATE: FieldRef<"payments", 'DateTime'>
    readonly PAYMENT_METHOD: FieldRef<"payments", 'payments_PAYMENT_METHOD'>
    readonly STATUS: FieldRef<"payments", 'payments_STATUS'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.users
   */
  export type payments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * payments.credit_cards
   */
  export type payments$credit_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    where?: credit_cardsWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model plaidtransaction
   */

  export type AggregatePlaidtransaction = {
    _count: PlaidtransactionCountAggregateOutputType | null
    _avg: PlaidtransactionAvgAggregateOutputType | null
    _sum: PlaidtransactionSumAggregateOutputType | null
    _min: PlaidtransactionMinAggregateOutputType | null
    _max: PlaidtransactionMaxAggregateOutputType | null
  }

  export type PlaidtransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type PlaidtransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type PlaidtransactionMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    name: string | null
    amount: number | null
    date: Date | null
    account_id: string | null
    userId: string | null
    category: string | null
    iso_currency_code: string | null
    createdAt: Date | null
  }

  export type PlaidtransactionMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    name: string | null
    amount: number | null
    date: Date | null
    account_id: string | null
    userId: string | null
    category: string | null
    iso_currency_code: string | null
    createdAt: Date | null
  }

  export type PlaidtransactionCountAggregateOutputType = {
    id: number
    transactionId: number
    name: number
    amount: number
    date: number
    account_id: number
    userId: number
    category: number
    iso_currency_code: number
    createdAt: number
    _all: number
  }


  export type PlaidtransactionAvgAggregateInputType = {
    amount?: true
  }

  export type PlaidtransactionSumAggregateInputType = {
    amount?: true
  }

  export type PlaidtransactionMinAggregateInputType = {
    id?: true
    transactionId?: true
    name?: true
    amount?: true
    date?: true
    account_id?: true
    userId?: true
    category?: true
    iso_currency_code?: true
    createdAt?: true
  }

  export type PlaidtransactionMaxAggregateInputType = {
    id?: true
    transactionId?: true
    name?: true
    amount?: true
    date?: true
    account_id?: true
    userId?: true
    category?: true
    iso_currency_code?: true
    createdAt?: true
  }

  export type PlaidtransactionCountAggregateInputType = {
    id?: true
    transactionId?: true
    name?: true
    amount?: true
    date?: true
    account_id?: true
    userId?: true
    category?: true
    iso_currency_code?: true
    createdAt?: true
    _all?: true
  }

  export type PlaidtransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plaidtransaction to aggregate.
     */
    where?: plaidtransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaidtransactions to fetch.
     */
    orderBy?: plaidtransactionOrderByWithRelationInput | plaidtransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plaidtransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaidtransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaidtransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plaidtransactions
    **/
    _count?: true | PlaidtransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaidtransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaidtransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaidtransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaidtransactionMaxAggregateInputType
  }

  export type GetPlaidtransactionAggregateType<T extends PlaidtransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaidtransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaidtransaction[P]>
      : GetScalarType<T[P], AggregatePlaidtransaction[P]>
  }




  export type plaidtransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plaidtransactionWhereInput
    orderBy?: plaidtransactionOrderByWithAggregationInput | plaidtransactionOrderByWithAggregationInput[]
    by: PlaidtransactionScalarFieldEnum[] | PlaidtransactionScalarFieldEnum
    having?: plaidtransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaidtransactionCountAggregateInputType | true
    _avg?: PlaidtransactionAvgAggregateInputType
    _sum?: PlaidtransactionSumAggregateInputType
    _min?: PlaidtransactionMinAggregateInputType
    _max?: PlaidtransactionMaxAggregateInputType
  }

  export type PlaidtransactionGroupByOutputType = {
    id: string
    transactionId: string | null
    name: string
    amount: number
    date: Date
    account_id: string
    userId: string
    category: string | null
    iso_currency_code: string | null
    createdAt: Date | null
    _count: PlaidtransactionCountAggregateOutputType | null
    _avg: PlaidtransactionAvgAggregateOutputType | null
    _sum: PlaidtransactionSumAggregateOutputType | null
    _min: PlaidtransactionMinAggregateOutputType | null
    _max: PlaidtransactionMaxAggregateOutputType | null
  }

  type GetPlaidtransactionGroupByPayload<T extends plaidtransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaidtransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaidtransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaidtransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PlaidtransactionGroupByOutputType[P]>
        }
      >
    >


  export type plaidtransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    name?: boolean
    amount?: boolean
    date?: boolean
    account_id?: boolean
    userId?: boolean
    category?: boolean
    iso_currency_code?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["plaidtransaction"]>



  export type plaidtransactionSelectScalar = {
    id?: boolean
    transactionId?: boolean
    name?: boolean
    amount?: boolean
    date?: boolean
    account_id?: boolean
    userId?: boolean
    category?: boolean
    iso_currency_code?: boolean
    createdAt?: boolean
  }

  export type plaidtransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "name" | "amount" | "date" | "account_id" | "userId" | "category" | "iso_currency_code" | "createdAt", ExtArgs["result"]["plaidtransaction"]>

  export type $plaidtransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plaidtransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string | null
      name: string
      amount: number
      date: Date
      account_id: string
      userId: string
      category: string | null
      iso_currency_code: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["plaidtransaction"]>
    composites: {}
  }

  type plaidtransactionGetPayload<S extends boolean | null | undefined | plaidtransactionDefaultArgs> = $Result.GetResult<Prisma.$plaidtransactionPayload, S>

  type plaidtransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plaidtransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaidtransactionCountAggregateInputType | true
    }

  export interface plaidtransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plaidtransaction'], meta: { name: 'plaidtransaction' } }
    /**
     * Find zero or one Plaidtransaction that matches the filter.
     * @param {plaidtransactionFindUniqueArgs} args - Arguments to find a Plaidtransaction
     * @example
     * // Get one Plaidtransaction
     * const plaidtransaction = await prisma.plaidtransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plaidtransactionFindUniqueArgs>(args: SelectSubset<T, plaidtransactionFindUniqueArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plaidtransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plaidtransactionFindUniqueOrThrowArgs} args - Arguments to find a Plaidtransaction
     * @example
     * // Get one Plaidtransaction
     * const plaidtransaction = await prisma.plaidtransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plaidtransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, plaidtransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plaidtransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaidtransactionFindFirstArgs} args - Arguments to find a Plaidtransaction
     * @example
     * // Get one Plaidtransaction
     * const plaidtransaction = await prisma.plaidtransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plaidtransactionFindFirstArgs>(args?: SelectSubset<T, plaidtransactionFindFirstArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plaidtransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaidtransactionFindFirstOrThrowArgs} args - Arguments to find a Plaidtransaction
     * @example
     * // Get one Plaidtransaction
     * const plaidtransaction = await prisma.plaidtransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plaidtransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, plaidtransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plaidtransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaidtransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plaidtransactions
     * const plaidtransactions = await prisma.plaidtransaction.findMany()
     * 
     * // Get first 10 Plaidtransactions
     * const plaidtransactions = await prisma.plaidtransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plaidtransactionWithIdOnly = await prisma.plaidtransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plaidtransactionFindManyArgs>(args?: SelectSubset<T, plaidtransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plaidtransaction.
     * @param {plaidtransactionCreateArgs} args - Arguments to create a Plaidtransaction.
     * @example
     * // Create one Plaidtransaction
     * const Plaidtransaction = await prisma.plaidtransaction.create({
     *   data: {
     *     // ... data to create a Plaidtransaction
     *   }
     * })
     * 
     */
    create<T extends plaidtransactionCreateArgs>(args: SelectSubset<T, plaidtransactionCreateArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plaidtransactions.
     * @param {plaidtransactionCreateManyArgs} args - Arguments to create many Plaidtransactions.
     * @example
     * // Create many Plaidtransactions
     * const plaidtransaction = await prisma.plaidtransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plaidtransactionCreateManyArgs>(args?: SelectSubset<T, plaidtransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plaidtransaction.
     * @param {plaidtransactionDeleteArgs} args - Arguments to delete one Plaidtransaction.
     * @example
     * // Delete one Plaidtransaction
     * const Plaidtransaction = await prisma.plaidtransaction.delete({
     *   where: {
     *     // ... filter to delete one Plaidtransaction
     *   }
     * })
     * 
     */
    delete<T extends plaidtransactionDeleteArgs>(args: SelectSubset<T, plaidtransactionDeleteArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plaidtransaction.
     * @param {plaidtransactionUpdateArgs} args - Arguments to update one Plaidtransaction.
     * @example
     * // Update one Plaidtransaction
     * const plaidtransaction = await prisma.plaidtransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plaidtransactionUpdateArgs>(args: SelectSubset<T, plaidtransactionUpdateArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plaidtransactions.
     * @param {plaidtransactionDeleteManyArgs} args - Arguments to filter Plaidtransactions to delete.
     * @example
     * // Delete a few Plaidtransactions
     * const { count } = await prisma.plaidtransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plaidtransactionDeleteManyArgs>(args?: SelectSubset<T, plaidtransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plaidtransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaidtransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plaidtransactions
     * const plaidtransaction = await prisma.plaidtransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plaidtransactionUpdateManyArgs>(args: SelectSubset<T, plaidtransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plaidtransaction.
     * @param {plaidtransactionUpsertArgs} args - Arguments to update or create a Plaidtransaction.
     * @example
     * // Update or create a Plaidtransaction
     * const plaidtransaction = await prisma.plaidtransaction.upsert({
     *   create: {
     *     // ... data to create a Plaidtransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plaidtransaction we want to update
     *   }
     * })
     */
    upsert<T extends plaidtransactionUpsertArgs>(args: SelectSubset<T, plaidtransactionUpsertArgs<ExtArgs>>): Prisma__plaidtransactionClient<$Result.GetResult<Prisma.$plaidtransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plaidtransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaidtransactionCountArgs} args - Arguments to filter Plaidtransactions to count.
     * @example
     * // Count the number of Plaidtransactions
     * const count = await prisma.plaidtransaction.count({
     *   where: {
     *     // ... the filter for the Plaidtransactions we want to count
     *   }
     * })
    **/
    count<T extends plaidtransactionCountArgs>(
      args?: Subset<T, plaidtransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaidtransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plaidtransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidtransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaidtransactionAggregateArgs>(args: Subset<T, PlaidtransactionAggregateArgs>): Prisma.PrismaPromise<GetPlaidtransactionAggregateType<T>>

    /**
     * Group by Plaidtransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaidtransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plaidtransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plaidtransactionGroupByArgs['orderBy'] }
        : { orderBy?: plaidtransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plaidtransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaidtransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plaidtransaction model
   */
  readonly fields: plaidtransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plaidtransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plaidtransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plaidtransaction model
   */
  interface plaidtransactionFieldRefs {
    readonly id: FieldRef<"plaidtransaction", 'String'>
    readonly transactionId: FieldRef<"plaidtransaction", 'String'>
    readonly name: FieldRef<"plaidtransaction", 'String'>
    readonly amount: FieldRef<"plaidtransaction", 'Float'>
    readonly date: FieldRef<"plaidtransaction", 'DateTime'>
    readonly account_id: FieldRef<"plaidtransaction", 'String'>
    readonly userId: FieldRef<"plaidtransaction", 'String'>
    readonly category: FieldRef<"plaidtransaction", 'String'>
    readonly iso_currency_code: FieldRef<"plaidtransaction", 'String'>
    readonly createdAt: FieldRef<"plaidtransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * plaidtransaction findUnique
   */
  export type plaidtransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * Filter, which plaidtransaction to fetch.
     */
    where: plaidtransactionWhereUniqueInput
  }

  /**
   * plaidtransaction findUniqueOrThrow
   */
  export type plaidtransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * Filter, which plaidtransaction to fetch.
     */
    where: plaidtransactionWhereUniqueInput
  }

  /**
   * plaidtransaction findFirst
   */
  export type plaidtransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * Filter, which plaidtransaction to fetch.
     */
    where?: plaidtransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaidtransactions to fetch.
     */
    orderBy?: plaidtransactionOrderByWithRelationInput | plaidtransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plaidtransactions.
     */
    cursor?: plaidtransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaidtransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaidtransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plaidtransactions.
     */
    distinct?: PlaidtransactionScalarFieldEnum | PlaidtransactionScalarFieldEnum[]
  }

  /**
   * plaidtransaction findFirstOrThrow
   */
  export type plaidtransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * Filter, which plaidtransaction to fetch.
     */
    where?: plaidtransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaidtransactions to fetch.
     */
    orderBy?: plaidtransactionOrderByWithRelationInput | plaidtransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plaidtransactions.
     */
    cursor?: plaidtransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaidtransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaidtransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plaidtransactions.
     */
    distinct?: PlaidtransactionScalarFieldEnum | PlaidtransactionScalarFieldEnum[]
  }

  /**
   * plaidtransaction findMany
   */
  export type plaidtransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * Filter, which plaidtransactions to fetch.
     */
    where?: plaidtransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaidtransactions to fetch.
     */
    orderBy?: plaidtransactionOrderByWithRelationInput | plaidtransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plaidtransactions.
     */
    cursor?: plaidtransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaidtransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaidtransactions.
     */
    skip?: number
    distinct?: PlaidtransactionScalarFieldEnum | PlaidtransactionScalarFieldEnum[]
  }

  /**
   * plaidtransaction create
   */
  export type plaidtransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a plaidtransaction.
     */
    data: XOR<plaidtransactionCreateInput, plaidtransactionUncheckedCreateInput>
  }

  /**
   * plaidtransaction createMany
   */
  export type plaidtransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plaidtransactions.
     */
    data: plaidtransactionCreateManyInput | plaidtransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plaidtransaction update
   */
  export type plaidtransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a plaidtransaction.
     */
    data: XOR<plaidtransactionUpdateInput, plaidtransactionUncheckedUpdateInput>
    /**
     * Choose, which plaidtransaction to update.
     */
    where: plaidtransactionWhereUniqueInput
  }

  /**
   * plaidtransaction updateMany
   */
  export type plaidtransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plaidtransactions.
     */
    data: XOR<plaidtransactionUpdateManyMutationInput, plaidtransactionUncheckedUpdateManyInput>
    /**
     * Filter which plaidtransactions to update
     */
    where?: plaidtransactionWhereInput
    /**
     * Limit how many plaidtransactions to update.
     */
    limit?: number
  }

  /**
   * plaidtransaction upsert
   */
  export type plaidtransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the plaidtransaction to update in case it exists.
     */
    where: plaidtransactionWhereUniqueInput
    /**
     * In case the plaidtransaction found by the `where` argument doesn't exist, create a new plaidtransaction with this data.
     */
    create: XOR<plaidtransactionCreateInput, plaidtransactionUncheckedCreateInput>
    /**
     * In case the plaidtransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plaidtransactionUpdateInput, plaidtransactionUncheckedUpdateInput>
  }

  /**
   * plaidtransaction delete
   */
  export type plaidtransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
    /**
     * Filter which plaidtransaction to delete.
     */
    where: plaidtransactionWhereUniqueInput
  }

  /**
   * plaidtransaction deleteMany
   */
  export type plaidtransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plaidtransactions to delete
     */
    where?: plaidtransactionWhereInput
    /**
     * Limit how many plaidtransactions to delete.
     */
    limit?: number
  }

  /**
   * plaidtransaction without action
   */
  export type plaidtransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaidtransaction
     */
    select?: plaidtransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaidtransaction
     */
    omit?: plaidtransactionOmit<ExtArgs> | null
  }


  /**
   * Model security_log
   */

  export type AggregateSecurity_log = {
    _count: Security_logCountAggregateOutputType | null
    _avg: Security_logAvgAggregateOutputType | null
    _sum: Security_logSumAggregateOutputType | null
    _min: Security_logMinAggregateOutputType | null
    _max: Security_logMaxAggregateOutputType | null
  }

  export type Security_logAvgAggregateOutputType = {
    LOG_ID: number | null
    USER_ID: number | null
  }

  export type Security_logSumAggregateOutputType = {
    LOG_ID: number | null
    USER_ID: number | null
  }

  export type Security_logMinAggregateOutputType = {
    LOG_ID: number | null
    USER_ID: number | null
    ACTION: string | null
    LOG_TIME: Date | null
  }

  export type Security_logMaxAggregateOutputType = {
    LOG_ID: number | null
    USER_ID: number | null
    ACTION: string | null
    LOG_TIME: Date | null
  }

  export type Security_logCountAggregateOutputType = {
    LOG_ID: number
    USER_ID: number
    ACTION: number
    LOG_TIME: number
    _all: number
  }


  export type Security_logAvgAggregateInputType = {
    LOG_ID?: true
    USER_ID?: true
  }

  export type Security_logSumAggregateInputType = {
    LOG_ID?: true
    USER_ID?: true
  }

  export type Security_logMinAggregateInputType = {
    LOG_ID?: true
    USER_ID?: true
    ACTION?: true
    LOG_TIME?: true
  }

  export type Security_logMaxAggregateInputType = {
    LOG_ID?: true
    USER_ID?: true
    ACTION?: true
    LOG_TIME?: true
  }

  export type Security_logCountAggregateInputType = {
    LOG_ID?: true
    USER_ID?: true
    ACTION?: true
    LOG_TIME?: true
    _all?: true
  }

  export type Security_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which security_log to aggregate.
     */
    where?: security_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_logs to fetch.
     */
    orderBy?: security_logOrderByWithRelationInput | security_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: security_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned security_logs
    **/
    _count?: true | Security_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Security_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Security_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Security_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Security_logMaxAggregateInputType
  }

  export type GetSecurity_logAggregateType<T extends Security_logAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurity_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurity_log[P]>
      : GetScalarType<T[P], AggregateSecurity_log[P]>
  }




  export type security_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: security_logWhereInput
    orderBy?: security_logOrderByWithAggregationInput | security_logOrderByWithAggregationInput[]
    by: Security_logScalarFieldEnum[] | Security_logScalarFieldEnum
    having?: security_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Security_logCountAggregateInputType | true
    _avg?: Security_logAvgAggregateInputType
    _sum?: Security_logSumAggregateInputType
    _min?: Security_logMinAggregateInputType
    _max?: Security_logMaxAggregateInputType
  }

  export type Security_logGroupByOutputType = {
    LOG_ID: number
    USER_ID: number | null
    ACTION: string
    LOG_TIME: Date | null
    _count: Security_logCountAggregateOutputType | null
    _avg: Security_logAvgAggregateOutputType | null
    _sum: Security_logSumAggregateOutputType | null
    _min: Security_logMinAggregateOutputType | null
    _max: Security_logMaxAggregateOutputType | null
  }

  type GetSecurity_logGroupByPayload<T extends security_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Security_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Security_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Security_logGroupByOutputType[P]>
            : GetScalarType<T[P], Security_logGroupByOutputType[P]>
        }
      >
    >


  export type security_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LOG_ID?: boolean
    USER_ID?: boolean
    ACTION?: boolean
    LOG_TIME?: boolean
    users?: boolean | security_log$usersArgs<ExtArgs>
  }, ExtArgs["result"]["security_log"]>



  export type security_logSelectScalar = {
    LOG_ID?: boolean
    USER_ID?: boolean
    ACTION?: boolean
    LOG_TIME?: boolean
  }

  export type security_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"LOG_ID" | "USER_ID" | "ACTION" | "LOG_TIME", ExtArgs["result"]["security_log"]>
  export type security_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | security_log$usersArgs<ExtArgs>
  }

  export type $security_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "security_log"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      LOG_ID: number
      USER_ID: number | null
      ACTION: string
      LOG_TIME: Date | null
    }, ExtArgs["result"]["security_log"]>
    composites: {}
  }

  type security_logGetPayload<S extends boolean | null | undefined | security_logDefaultArgs> = $Result.GetResult<Prisma.$security_logPayload, S>

  type security_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<security_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Security_logCountAggregateInputType | true
    }

  export interface security_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['security_log'], meta: { name: 'security_log' } }
    /**
     * Find zero or one Security_log that matches the filter.
     * @param {security_logFindUniqueArgs} args - Arguments to find a Security_log
     * @example
     * // Get one Security_log
     * const security_log = await prisma.security_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends security_logFindUniqueArgs>(args: SelectSubset<T, security_logFindUniqueArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Security_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {security_logFindUniqueOrThrowArgs} args - Arguments to find a Security_log
     * @example
     * // Get one Security_log
     * const security_log = await prisma.security_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends security_logFindUniqueOrThrowArgs>(args: SelectSubset<T, security_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Security_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_logFindFirstArgs} args - Arguments to find a Security_log
     * @example
     * // Get one Security_log
     * const security_log = await prisma.security_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends security_logFindFirstArgs>(args?: SelectSubset<T, security_logFindFirstArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Security_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_logFindFirstOrThrowArgs} args - Arguments to find a Security_log
     * @example
     * // Get one Security_log
     * const security_log = await prisma.security_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends security_logFindFirstOrThrowArgs>(args?: SelectSubset<T, security_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Security_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Security_logs
     * const security_logs = await prisma.security_log.findMany()
     * 
     * // Get first 10 Security_logs
     * const security_logs = await prisma.security_log.findMany({ take: 10 })
     * 
     * // Only select the `LOG_ID`
     * const security_logWithLOG_IDOnly = await prisma.security_log.findMany({ select: { LOG_ID: true } })
     * 
     */
    findMany<T extends security_logFindManyArgs>(args?: SelectSubset<T, security_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Security_log.
     * @param {security_logCreateArgs} args - Arguments to create a Security_log.
     * @example
     * // Create one Security_log
     * const Security_log = await prisma.security_log.create({
     *   data: {
     *     // ... data to create a Security_log
     *   }
     * })
     * 
     */
    create<T extends security_logCreateArgs>(args: SelectSubset<T, security_logCreateArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Security_logs.
     * @param {security_logCreateManyArgs} args - Arguments to create many Security_logs.
     * @example
     * // Create many Security_logs
     * const security_log = await prisma.security_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends security_logCreateManyArgs>(args?: SelectSubset<T, security_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Security_log.
     * @param {security_logDeleteArgs} args - Arguments to delete one Security_log.
     * @example
     * // Delete one Security_log
     * const Security_log = await prisma.security_log.delete({
     *   where: {
     *     // ... filter to delete one Security_log
     *   }
     * })
     * 
     */
    delete<T extends security_logDeleteArgs>(args: SelectSubset<T, security_logDeleteArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Security_log.
     * @param {security_logUpdateArgs} args - Arguments to update one Security_log.
     * @example
     * // Update one Security_log
     * const security_log = await prisma.security_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends security_logUpdateArgs>(args: SelectSubset<T, security_logUpdateArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Security_logs.
     * @param {security_logDeleteManyArgs} args - Arguments to filter Security_logs to delete.
     * @example
     * // Delete a few Security_logs
     * const { count } = await prisma.security_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends security_logDeleteManyArgs>(args?: SelectSubset<T, security_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Security_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Security_logs
     * const security_log = await prisma.security_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends security_logUpdateManyArgs>(args: SelectSubset<T, security_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Security_log.
     * @param {security_logUpsertArgs} args - Arguments to update or create a Security_log.
     * @example
     * // Update or create a Security_log
     * const security_log = await prisma.security_log.upsert({
     *   create: {
     *     // ... data to create a Security_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Security_log we want to update
     *   }
     * })
     */
    upsert<T extends security_logUpsertArgs>(args: SelectSubset<T, security_logUpsertArgs<ExtArgs>>): Prisma__security_logClient<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Security_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_logCountArgs} args - Arguments to filter Security_logs to count.
     * @example
     * // Count the number of Security_logs
     * const count = await prisma.security_log.count({
     *   where: {
     *     // ... the filter for the Security_logs we want to count
     *   }
     * })
    **/
    count<T extends security_logCountArgs>(
      args?: Subset<T, security_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Security_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Security_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Security_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Security_logAggregateArgs>(args: Subset<T, Security_logAggregateArgs>): Prisma.PrismaPromise<GetSecurity_logAggregateType<T>>

    /**
     * Group by Security_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends security_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: security_logGroupByArgs['orderBy'] }
        : { orderBy?: security_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, security_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurity_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the security_log model
   */
  readonly fields: security_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for security_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__security_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends security_log$usersArgs<ExtArgs> = {}>(args?: Subset<T, security_log$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the security_log model
   */
  interface security_logFieldRefs {
    readonly LOG_ID: FieldRef<"security_log", 'Int'>
    readonly USER_ID: FieldRef<"security_log", 'Int'>
    readonly ACTION: FieldRef<"security_log", 'String'>
    readonly LOG_TIME: FieldRef<"security_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * security_log findUnique
   */
  export type security_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * Filter, which security_log to fetch.
     */
    where: security_logWhereUniqueInput
  }

  /**
   * security_log findUniqueOrThrow
   */
  export type security_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * Filter, which security_log to fetch.
     */
    where: security_logWhereUniqueInput
  }

  /**
   * security_log findFirst
   */
  export type security_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * Filter, which security_log to fetch.
     */
    where?: security_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_logs to fetch.
     */
    orderBy?: security_logOrderByWithRelationInput | security_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for security_logs.
     */
    cursor?: security_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of security_logs.
     */
    distinct?: Security_logScalarFieldEnum | Security_logScalarFieldEnum[]
  }

  /**
   * security_log findFirstOrThrow
   */
  export type security_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * Filter, which security_log to fetch.
     */
    where?: security_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_logs to fetch.
     */
    orderBy?: security_logOrderByWithRelationInput | security_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for security_logs.
     */
    cursor?: security_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of security_logs.
     */
    distinct?: Security_logScalarFieldEnum | Security_logScalarFieldEnum[]
  }

  /**
   * security_log findMany
   */
  export type security_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * Filter, which security_logs to fetch.
     */
    where?: security_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_logs to fetch.
     */
    orderBy?: security_logOrderByWithRelationInput | security_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing security_logs.
     */
    cursor?: security_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_logs.
     */
    skip?: number
    distinct?: Security_logScalarFieldEnum | Security_logScalarFieldEnum[]
  }

  /**
   * security_log create
   */
  export type security_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * The data needed to create a security_log.
     */
    data: XOR<security_logCreateInput, security_logUncheckedCreateInput>
  }

  /**
   * security_log createMany
   */
  export type security_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many security_logs.
     */
    data: security_logCreateManyInput | security_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * security_log update
   */
  export type security_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * The data needed to update a security_log.
     */
    data: XOR<security_logUpdateInput, security_logUncheckedUpdateInput>
    /**
     * Choose, which security_log to update.
     */
    where: security_logWhereUniqueInput
  }

  /**
   * security_log updateMany
   */
  export type security_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update security_logs.
     */
    data: XOR<security_logUpdateManyMutationInput, security_logUncheckedUpdateManyInput>
    /**
     * Filter which security_logs to update
     */
    where?: security_logWhereInput
    /**
     * Limit how many security_logs to update.
     */
    limit?: number
  }

  /**
   * security_log upsert
   */
  export type security_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * The filter to search for the security_log to update in case it exists.
     */
    where: security_logWhereUniqueInput
    /**
     * In case the security_log found by the `where` argument doesn't exist, create a new security_log with this data.
     */
    create: XOR<security_logCreateInput, security_logUncheckedCreateInput>
    /**
     * In case the security_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<security_logUpdateInput, security_logUncheckedUpdateInput>
  }

  /**
   * security_log delete
   */
  export type security_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    /**
     * Filter which security_log to delete.
     */
    where: security_logWhereUniqueInput
  }

  /**
   * security_log deleteMany
   */
  export type security_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which security_logs to delete
     */
    where?: security_logWhereInput
    /**
     * Limit how many security_logs to delete.
     */
    limit?: number
  }

  /**
   * security_log.users
   */
  export type security_log$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * security_log without action
   */
  export type security_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
  }


  /**
   * Model settlements
   */

  export type AggregateSettlements = {
    _count: SettlementsCountAggregateOutputType | null
    _avg: SettlementsAvgAggregateOutputType | null
    _sum: SettlementsSumAggregateOutputType | null
    _min: SettlementsMinAggregateOutputType | null
    _max: SettlementsMaxAggregateOutputType | null
  }

  export type SettlementsAvgAggregateOutputType = {
    SET_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    ORIGINAL_AMOUNT: Decimal | null
    SETTLED_AMOUNT: Decimal | null
  }

  export type SettlementsSumAggregateOutputType = {
    SET_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    ORIGINAL_AMOUNT: Decimal | null
    SETTLED_AMOUNT: Decimal | null
  }

  export type SettlementsMinAggregateOutputType = {
    SET_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    ORIGINAL_AMOUNT: Decimal | null
    SETTLED_AMOUNT: Decimal | null
    SET_DATE: Date | null
    STATUS: $Enums.settlements_STATUS | null
  }

  export type SettlementsMaxAggregateOutputType = {
    SET_ID: number | null
    USER_ID: number | null
    CARD_ID: number | null
    ORIGINAL_AMOUNT: Decimal | null
    SETTLED_AMOUNT: Decimal | null
    SET_DATE: Date | null
    STATUS: $Enums.settlements_STATUS | null
  }

  export type SettlementsCountAggregateOutputType = {
    SET_ID: number
    USER_ID: number
    CARD_ID: number
    ORIGINAL_AMOUNT: number
    SETTLED_AMOUNT: number
    SET_DATE: number
    STATUS: number
    _all: number
  }


  export type SettlementsAvgAggregateInputType = {
    SET_ID?: true
    USER_ID?: true
    CARD_ID?: true
    ORIGINAL_AMOUNT?: true
    SETTLED_AMOUNT?: true
  }

  export type SettlementsSumAggregateInputType = {
    SET_ID?: true
    USER_ID?: true
    CARD_ID?: true
    ORIGINAL_AMOUNT?: true
    SETTLED_AMOUNT?: true
  }

  export type SettlementsMinAggregateInputType = {
    SET_ID?: true
    USER_ID?: true
    CARD_ID?: true
    ORIGINAL_AMOUNT?: true
    SETTLED_AMOUNT?: true
    SET_DATE?: true
    STATUS?: true
  }

  export type SettlementsMaxAggregateInputType = {
    SET_ID?: true
    USER_ID?: true
    CARD_ID?: true
    ORIGINAL_AMOUNT?: true
    SETTLED_AMOUNT?: true
    SET_DATE?: true
    STATUS?: true
  }

  export type SettlementsCountAggregateInputType = {
    SET_ID?: true
    USER_ID?: true
    CARD_ID?: true
    ORIGINAL_AMOUNT?: true
    SETTLED_AMOUNT?: true
    SET_DATE?: true
    STATUS?: true
    _all?: true
  }

  export type SettlementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settlements to aggregate.
     */
    where?: settlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlements to fetch.
     */
    orderBy?: settlementsOrderByWithRelationInput | settlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settlements
    **/
    _count?: true | SettlementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettlementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettlementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettlementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettlementsMaxAggregateInputType
  }

  export type GetSettlementsAggregateType<T extends SettlementsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlements[P]>
      : GetScalarType<T[P], AggregateSettlements[P]>
  }




  export type settlementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settlementsWhereInput
    orderBy?: settlementsOrderByWithAggregationInput | settlementsOrderByWithAggregationInput[]
    by: SettlementsScalarFieldEnum[] | SettlementsScalarFieldEnum
    having?: settlementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettlementsCountAggregateInputType | true
    _avg?: SettlementsAvgAggregateInputType
    _sum?: SettlementsSumAggregateInputType
    _min?: SettlementsMinAggregateInputType
    _max?: SettlementsMaxAggregateInputType
  }

  export type SettlementsGroupByOutputType = {
    SET_ID: number
    USER_ID: number | null
    CARD_ID: number | null
    ORIGINAL_AMOUNT: Decimal
    SETTLED_AMOUNT: Decimal
    SET_DATE: Date | null
    STATUS: $Enums.settlements_STATUS | null
    _count: SettlementsCountAggregateOutputType | null
    _avg: SettlementsAvgAggregateOutputType | null
    _sum: SettlementsSumAggregateOutputType | null
    _min: SettlementsMinAggregateOutputType | null
    _max: SettlementsMaxAggregateOutputType | null
  }

  type GetSettlementsGroupByPayload<T extends settlementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettlementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettlementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettlementsGroupByOutputType[P]>
            : GetScalarType<T[P], SettlementsGroupByOutputType[P]>
        }
      >
    >


  export type settlementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SET_ID?: boolean
    USER_ID?: boolean
    CARD_ID?: boolean
    ORIGINAL_AMOUNT?: boolean
    SETTLED_AMOUNT?: boolean
    SET_DATE?: boolean
    STATUS?: boolean
    credit_cards?: boolean | settlements$credit_cardsArgs<ExtArgs>
    users?: boolean | settlements$usersArgs<ExtArgs>
  }, ExtArgs["result"]["settlements"]>



  export type settlementsSelectScalar = {
    SET_ID?: boolean
    USER_ID?: boolean
    CARD_ID?: boolean
    ORIGINAL_AMOUNT?: boolean
    SETTLED_AMOUNT?: boolean
    SET_DATE?: boolean
    STATUS?: boolean
  }

  export type settlementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SET_ID" | "USER_ID" | "CARD_ID" | "ORIGINAL_AMOUNT" | "SETTLED_AMOUNT" | "SET_DATE" | "STATUS", ExtArgs["result"]["settlements"]>
  export type settlementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_cards?: boolean | settlements$credit_cardsArgs<ExtArgs>
    users?: boolean | settlements$usersArgs<ExtArgs>
  }

  export type $settlementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settlements"
    objects: {
      credit_cards: Prisma.$credit_cardsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      SET_ID: number
      USER_ID: number | null
      CARD_ID: number | null
      ORIGINAL_AMOUNT: Prisma.Decimal
      SETTLED_AMOUNT: Prisma.Decimal
      SET_DATE: Date | null
      STATUS: $Enums.settlements_STATUS | null
    }, ExtArgs["result"]["settlements"]>
    composites: {}
  }

  type settlementsGetPayload<S extends boolean | null | undefined | settlementsDefaultArgs> = $Result.GetResult<Prisma.$settlementsPayload, S>

  type settlementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settlementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettlementsCountAggregateInputType | true
    }

  export interface settlementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settlements'], meta: { name: 'settlements' } }
    /**
     * Find zero or one Settlements that matches the filter.
     * @param {settlementsFindUniqueArgs} args - Arguments to find a Settlements
     * @example
     * // Get one Settlements
     * const settlements = await prisma.settlements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settlementsFindUniqueArgs>(args: SelectSubset<T, settlementsFindUniqueArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settlements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settlementsFindUniqueOrThrowArgs} args - Arguments to find a Settlements
     * @example
     * // Get one Settlements
     * const settlements = await prisma.settlements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settlementsFindUniqueOrThrowArgs>(args: SelectSubset<T, settlementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlementsFindFirstArgs} args - Arguments to find a Settlements
     * @example
     * // Get one Settlements
     * const settlements = await prisma.settlements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settlementsFindFirstArgs>(args?: SelectSubset<T, settlementsFindFirstArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlementsFindFirstOrThrowArgs} args - Arguments to find a Settlements
     * @example
     * // Get one Settlements
     * const settlements = await prisma.settlements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settlementsFindFirstOrThrowArgs>(args?: SelectSubset<T, settlementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settlements
     * const settlements = await prisma.settlements.findMany()
     * 
     * // Get first 10 Settlements
     * const settlements = await prisma.settlements.findMany({ take: 10 })
     * 
     * // Only select the `SET_ID`
     * const settlementsWithSET_IDOnly = await prisma.settlements.findMany({ select: { SET_ID: true } })
     * 
     */
    findMany<T extends settlementsFindManyArgs>(args?: SelectSubset<T, settlementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settlements.
     * @param {settlementsCreateArgs} args - Arguments to create a Settlements.
     * @example
     * // Create one Settlements
     * const Settlements = await prisma.settlements.create({
     *   data: {
     *     // ... data to create a Settlements
     *   }
     * })
     * 
     */
    create<T extends settlementsCreateArgs>(args: SelectSubset<T, settlementsCreateArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settlements.
     * @param {settlementsCreateManyArgs} args - Arguments to create many Settlements.
     * @example
     * // Create many Settlements
     * const settlements = await prisma.settlements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settlementsCreateManyArgs>(args?: SelectSubset<T, settlementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settlements.
     * @param {settlementsDeleteArgs} args - Arguments to delete one Settlements.
     * @example
     * // Delete one Settlements
     * const Settlements = await prisma.settlements.delete({
     *   where: {
     *     // ... filter to delete one Settlements
     *   }
     * })
     * 
     */
    delete<T extends settlementsDeleteArgs>(args: SelectSubset<T, settlementsDeleteArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settlements.
     * @param {settlementsUpdateArgs} args - Arguments to update one Settlements.
     * @example
     * // Update one Settlements
     * const settlements = await prisma.settlements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settlementsUpdateArgs>(args: SelectSubset<T, settlementsUpdateArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settlements.
     * @param {settlementsDeleteManyArgs} args - Arguments to filter Settlements to delete.
     * @example
     * // Delete a few Settlements
     * const { count } = await prisma.settlements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settlementsDeleteManyArgs>(args?: SelectSubset<T, settlementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settlements
     * const settlements = await prisma.settlements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settlementsUpdateManyArgs>(args: SelectSubset<T, settlementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settlements.
     * @param {settlementsUpsertArgs} args - Arguments to update or create a Settlements.
     * @example
     * // Update or create a Settlements
     * const settlements = await prisma.settlements.upsert({
     *   create: {
     *     // ... data to create a Settlements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settlements we want to update
     *   }
     * })
     */
    upsert<T extends settlementsUpsertArgs>(args: SelectSubset<T, settlementsUpsertArgs<ExtArgs>>): Prisma__settlementsClient<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlementsCountArgs} args - Arguments to filter Settlements to count.
     * @example
     * // Count the number of Settlements
     * const count = await prisma.settlements.count({
     *   where: {
     *     // ... the filter for the Settlements we want to count
     *   }
     * })
    **/
    count<T extends settlementsCountArgs>(
      args?: Subset<T, settlementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettlementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettlementsAggregateArgs>(args: Subset<T, SettlementsAggregateArgs>): Prisma.PrismaPromise<GetSettlementsAggregateType<T>>

    /**
     * Group by Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settlementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settlementsGroupByArgs['orderBy'] }
        : { orderBy?: settlementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settlementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settlements model
   */
  readonly fields: settlementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settlements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settlementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credit_cards<T extends settlements$credit_cardsArgs<ExtArgs> = {}>(args?: Subset<T, settlements$credit_cardsArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends settlements$usersArgs<ExtArgs> = {}>(args?: Subset<T, settlements$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settlements model
   */
  interface settlementsFieldRefs {
    readonly SET_ID: FieldRef<"settlements", 'Int'>
    readonly USER_ID: FieldRef<"settlements", 'Int'>
    readonly CARD_ID: FieldRef<"settlements", 'Int'>
    readonly ORIGINAL_AMOUNT: FieldRef<"settlements", 'Decimal'>
    readonly SETTLED_AMOUNT: FieldRef<"settlements", 'Decimal'>
    readonly SET_DATE: FieldRef<"settlements", 'DateTime'>
    readonly STATUS: FieldRef<"settlements", 'settlements_STATUS'>
  }
    

  // Custom InputTypes
  /**
   * settlements findUnique
   */
  export type settlementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * Filter, which settlements to fetch.
     */
    where: settlementsWhereUniqueInput
  }

  /**
   * settlements findUniqueOrThrow
   */
  export type settlementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * Filter, which settlements to fetch.
     */
    where: settlementsWhereUniqueInput
  }

  /**
   * settlements findFirst
   */
  export type settlementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * Filter, which settlements to fetch.
     */
    where?: settlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlements to fetch.
     */
    orderBy?: settlementsOrderByWithRelationInput | settlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settlements.
     */
    cursor?: settlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settlements.
     */
    distinct?: SettlementsScalarFieldEnum | SettlementsScalarFieldEnum[]
  }

  /**
   * settlements findFirstOrThrow
   */
  export type settlementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * Filter, which settlements to fetch.
     */
    where?: settlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlements to fetch.
     */
    orderBy?: settlementsOrderByWithRelationInput | settlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settlements.
     */
    cursor?: settlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settlements.
     */
    distinct?: SettlementsScalarFieldEnum | SettlementsScalarFieldEnum[]
  }

  /**
   * settlements findMany
   */
  export type settlementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * Filter, which settlements to fetch.
     */
    where?: settlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlements to fetch.
     */
    orderBy?: settlementsOrderByWithRelationInput | settlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settlements.
     */
    cursor?: settlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlements.
     */
    skip?: number
    distinct?: SettlementsScalarFieldEnum | SettlementsScalarFieldEnum[]
  }

  /**
   * settlements create
   */
  export type settlementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * The data needed to create a settlements.
     */
    data: XOR<settlementsCreateInput, settlementsUncheckedCreateInput>
  }

  /**
   * settlements createMany
   */
  export type settlementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settlements.
     */
    data: settlementsCreateManyInput | settlementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settlements update
   */
  export type settlementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * The data needed to update a settlements.
     */
    data: XOR<settlementsUpdateInput, settlementsUncheckedUpdateInput>
    /**
     * Choose, which settlements to update.
     */
    where: settlementsWhereUniqueInput
  }

  /**
   * settlements updateMany
   */
  export type settlementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settlements.
     */
    data: XOR<settlementsUpdateManyMutationInput, settlementsUncheckedUpdateManyInput>
    /**
     * Filter which settlements to update
     */
    where?: settlementsWhereInput
    /**
     * Limit how many settlements to update.
     */
    limit?: number
  }

  /**
   * settlements upsert
   */
  export type settlementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * The filter to search for the settlements to update in case it exists.
     */
    where: settlementsWhereUniqueInput
    /**
     * In case the settlements found by the `where` argument doesn't exist, create a new settlements with this data.
     */
    create: XOR<settlementsCreateInput, settlementsUncheckedCreateInput>
    /**
     * In case the settlements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settlementsUpdateInput, settlementsUncheckedUpdateInput>
  }

  /**
   * settlements delete
   */
  export type settlementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    /**
     * Filter which settlements to delete.
     */
    where: settlementsWhereUniqueInput
  }

  /**
   * settlements deleteMany
   */
  export type settlementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settlements to delete
     */
    where?: settlementsWhereInput
    /**
     * Limit how many settlements to delete.
     */
    limit?: number
  }

  /**
   * settlements.credit_cards
   */
  export type settlements$credit_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    where?: credit_cardsWhereInput
  }

  /**
   * settlements.users
   */
  export type settlements$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * settlements without action
   */
  export type settlementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
  }


  /**
   * Model transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    TRANS_ID: number | null
    CARD_ID: number | null
    AMOUNT: Decimal | null
  }

  export type TransactionsSumAggregateOutputType = {
    TRANS_ID: number | null
    CARD_ID: number | null
    AMOUNT: Decimal | null
  }

  export type TransactionsMinAggregateOutputType = {
    TRANS_ID: number | null
    CARD_ID: number | null
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE | null
    AMOUNT: Decimal | null
    MERCHANT: string | null
    TRANS_DATE: Date | null
  }

  export type TransactionsMaxAggregateOutputType = {
    TRANS_ID: number | null
    CARD_ID: number | null
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE | null
    AMOUNT: Decimal | null
    MERCHANT: string | null
    TRANS_DATE: Date | null
  }

  export type TransactionsCountAggregateOutputType = {
    TRANS_ID: number
    CARD_ID: number
    TRANS_TYPE: number
    AMOUNT: number
    MERCHANT: number
    TRANS_DATE: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    TRANS_ID?: true
    CARD_ID?: true
    AMOUNT?: true
  }

  export type TransactionsSumAggregateInputType = {
    TRANS_ID?: true
    CARD_ID?: true
    AMOUNT?: true
  }

  export type TransactionsMinAggregateInputType = {
    TRANS_ID?: true
    CARD_ID?: true
    TRANS_TYPE?: true
    AMOUNT?: true
    MERCHANT?: true
    TRANS_DATE?: true
  }

  export type TransactionsMaxAggregateInputType = {
    TRANS_ID?: true
    CARD_ID?: true
    TRANS_TYPE?: true
    AMOUNT?: true
    MERCHANT?: true
    TRANS_DATE?: true
  }

  export type TransactionsCountAggregateInputType = {
    TRANS_ID?: true
    CARD_ID?: true
    TRANS_TYPE?: true
    AMOUNT?: true
    MERCHANT?: true
    TRANS_DATE?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithAggregationInput | transactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    TRANS_ID: number
    CARD_ID: number | null
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE
    AMOUNT: Decimal
    MERCHANT: string | null
    TRANS_DATE: Date | null
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TRANS_ID?: boolean
    CARD_ID?: boolean
    TRANS_TYPE?: boolean
    AMOUNT?: boolean
    MERCHANT?: boolean
    TRANS_DATE?: boolean
    credit_cards?: boolean | transactions$credit_cardsArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>



  export type transactionsSelectScalar = {
    TRANS_ID?: boolean
    CARD_ID?: boolean
    TRANS_TYPE?: boolean
    AMOUNT?: boolean
    MERCHANT?: boolean
    TRANS_DATE?: boolean
  }

  export type transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TRANS_ID" | "CARD_ID" | "TRANS_TYPE" | "AMOUNT" | "MERCHANT" | "TRANS_DATE", ExtArgs["result"]["transactions"]>
  export type transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_cards?: boolean | transactions$credit_cardsArgs<ExtArgs>
  }

  export type $transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactions"
    objects: {
      credit_cards: Prisma.$credit_cardsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      TRANS_ID: number
      CARD_ID: number | null
      TRANS_TYPE: $Enums.transactions_TRANS_TYPE
      AMOUNT: Prisma.Decimal
      MERCHANT: string | null
      TRANS_DATE: Date | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type transactionsGetPayload<S extends boolean | null | undefined | transactionsDefaultArgs> = $Result.GetResult<Prisma.$transactionsPayload, S>

  type transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactions'], meta: { name: 'transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionsFindUniqueArgs>(args: SelectSubset<T, transactionsFindUniqueArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionsFindFirstArgs>(args?: SelectSubset<T, transactionsFindFirstArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `TRANS_ID`
     * const transactionsWithTRANS_IDOnly = await prisma.transactions.findMany({ select: { TRANS_ID: true } })
     * 
     */
    findMany<T extends transactionsFindManyArgs>(args?: SelectSubset<T, transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends transactionsCreateArgs>(args: SelectSubset<T, transactionsCreateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionsCreateManyArgs>(args?: SelectSubset<T, transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends transactionsDeleteArgs>(args: SelectSubset<T, transactionsDeleteArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionsUpdateArgs>(args: SelectSubset<T, transactionsUpdateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionsDeleteManyArgs>(args?: SelectSubset<T, transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionsUpdateManyArgs>(args: SelectSubset<T, transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends transactionsUpsertArgs>(args: SelectSubset<T, transactionsUpsertArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionsGroupByArgs['orderBy'] }
        : { orderBy?: transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactions model
   */
  readonly fields: transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credit_cards<T extends transactions$credit_cardsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$credit_cardsArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactions model
   */
  interface transactionsFieldRefs {
    readonly TRANS_ID: FieldRef<"transactions", 'Int'>
    readonly CARD_ID: FieldRef<"transactions", 'Int'>
    readonly TRANS_TYPE: FieldRef<"transactions", 'transactions_TRANS_TYPE'>
    readonly AMOUNT: FieldRef<"transactions", 'Decimal'>
    readonly MERCHANT: FieldRef<"transactions", 'String'>
    readonly TRANS_DATE: FieldRef<"transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transactions findUnique
   */
  export type transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findFirst
   */
  export type transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions create
   */
  export type transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a transactions.
     */
    data: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }

  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactions update
   */
  export type transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }

  /**
   * transactions delete
   */
  export type transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transactions.credit_cards
   */
  export type transactions$credit_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    where?: credit_cardsWhereInput
  }

  /**
   * transactions without action
   */
  export type transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
  }


  /**
   * Model user_session
   */

  export type AggregateUser_session = {
    _count: User_sessionCountAggregateOutputType | null
    _avg: User_sessionAvgAggregateOutputType | null
    _sum: User_sessionSumAggregateOutputType | null
    _min: User_sessionMinAggregateOutputType | null
    _max: User_sessionMaxAggregateOutputType | null
  }

  export type User_sessionAvgAggregateOutputType = {
    SESSION_ID: number | null
    USER_ID: number | null
  }

  export type User_sessionSumAggregateOutputType = {
    SESSION_ID: number | null
    USER_ID: number | null
  }

  export type User_sessionMinAggregateOutputType = {
    SESSION_ID: number | null
    USER_ID: number | null
    SESSION_TOKEN: string | null
    EXPIRES: Date | null
  }

  export type User_sessionMaxAggregateOutputType = {
    SESSION_ID: number | null
    USER_ID: number | null
    SESSION_TOKEN: string | null
    EXPIRES: Date | null
  }

  export type User_sessionCountAggregateOutputType = {
    SESSION_ID: number
    USER_ID: number
    SESSION_TOKEN: number
    EXPIRES: number
    _all: number
  }


  export type User_sessionAvgAggregateInputType = {
    SESSION_ID?: true
    USER_ID?: true
  }

  export type User_sessionSumAggregateInputType = {
    SESSION_ID?: true
    USER_ID?: true
  }

  export type User_sessionMinAggregateInputType = {
    SESSION_ID?: true
    USER_ID?: true
    SESSION_TOKEN?: true
    EXPIRES?: true
  }

  export type User_sessionMaxAggregateInputType = {
    SESSION_ID?: true
    USER_ID?: true
    SESSION_TOKEN?: true
    EXPIRES?: true
  }

  export type User_sessionCountAggregateInputType = {
    SESSION_ID?: true
    USER_ID?: true
    SESSION_TOKEN?: true
    EXPIRES?: true
    _all?: true
  }

  export type User_sessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_session to aggregate.
     */
    where?: user_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionOrderByWithRelationInput | user_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_sessions
    **/
    _count?: true | User_sessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_sessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_sessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_sessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_sessionMaxAggregateInputType
  }

  export type GetUser_sessionAggregateType<T extends User_sessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_session]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_session[P]>
      : GetScalarType<T[P], AggregateUser_session[P]>
  }




  export type user_sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_sessionWhereInput
    orderBy?: user_sessionOrderByWithAggregationInput | user_sessionOrderByWithAggregationInput[]
    by: User_sessionScalarFieldEnum[] | User_sessionScalarFieldEnum
    having?: user_sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_sessionCountAggregateInputType | true
    _avg?: User_sessionAvgAggregateInputType
    _sum?: User_sessionSumAggregateInputType
    _min?: User_sessionMinAggregateInputType
    _max?: User_sessionMaxAggregateInputType
  }

  export type User_sessionGroupByOutputType = {
    SESSION_ID: number
    USER_ID: number | null
    SESSION_TOKEN: string
    EXPIRES: Date
    _count: User_sessionCountAggregateOutputType | null
    _avg: User_sessionAvgAggregateOutputType | null
    _sum: User_sessionSumAggregateOutputType | null
    _min: User_sessionMinAggregateOutputType | null
    _max: User_sessionMaxAggregateOutputType | null
  }

  type GetUser_sessionGroupByPayload<T extends user_sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_sessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_sessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_sessionGroupByOutputType[P]>
            : GetScalarType<T[P], User_sessionGroupByOutputType[P]>
        }
      >
    >


  export type user_sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SESSION_ID?: boolean
    USER_ID?: boolean
    SESSION_TOKEN?: boolean
    EXPIRES?: boolean
    users?: boolean | user_session$usersArgs<ExtArgs>
  }, ExtArgs["result"]["user_session"]>



  export type user_sessionSelectScalar = {
    SESSION_ID?: boolean
    USER_ID?: boolean
    SESSION_TOKEN?: boolean
    EXPIRES?: boolean
  }

  export type user_sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SESSION_ID" | "USER_ID" | "SESSION_TOKEN" | "EXPIRES", ExtArgs["result"]["user_session"]>
  export type user_sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | user_session$usersArgs<ExtArgs>
  }

  export type $user_sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_session"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      SESSION_ID: number
      USER_ID: number | null
      SESSION_TOKEN: string
      EXPIRES: Date
    }, ExtArgs["result"]["user_session"]>
    composites: {}
  }

  type user_sessionGetPayload<S extends boolean | null | undefined | user_sessionDefaultArgs> = $Result.GetResult<Prisma.$user_sessionPayload, S>

  type user_sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_sessionCountAggregateInputType | true
    }

  export interface user_sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_session'], meta: { name: 'user_session' } }
    /**
     * Find zero or one User_session that matches the filter.
     * @param {user_sessionFindUniqueArgs} args - Arguments to find a User_session
     * @example
     * // Get one User_session
     * const user_session = await prisma.user_session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_sessionFindUniqueArgs>(args: SelectSubset<T, user_sessionFindUniqueArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_sessionFindUniqueOrThrowArgs} args - Arguments to find a User_session
     * @example
     * // Get one User_session
     * const user_session = await prisma.user_session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, user_sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionFindFirstArgs} args - Arguments to find a User_session
     * @example
     * // Get one User_session
     * const user_session = await prisma.user_session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_sessionFindFirstArgs>(args?: SelectSubset<T, user_sessionFindFirstArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionFindFirstOrThrowArgs} args - Arguments to find a User_session
     * @example
     * // Get one User_session
     * const user_session = await prisma.user_session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, user_sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_sessions
     * const user_sessions = await prisma.user_session.findMany()
     * 
     * // Get first 10 User_sessions
     * const user_sessions = await prisma.user_session.findMany({ take: 10 })
     * 
     * // Only select the `SESSION_ID`
     * const user_sessionWithSESSION_IDOnly = await prisma.user_session.findMany({ select: { SESSION_ID: true } })
     * 
     */
    findMany<T extends user_sessionFindManyArgs>(args?: SelectSubset<T, user_sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_session.
     * @param {user_sessionCreateArgs} args - Arguments to create a User_session.
     * @example
     * // Create one User_session
     * const User_session = await prisma.user_session.create({
     *   data: {
     *     // ... data to create a User_session
     *   }
     * })
     * 
     */
    create<T extends user_sessionCreateArgs>(args: SelectSubset<T, user_sessionCreateArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_sessions.
     * @param {user_sessionCreateManyArgs} args - Arguments to create many User_sessions.
     * @example
     * // Create many User_sessions
     * const user_session = await prisma.user_session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_sessionCreateManyArgs>(args?: SelectSubset<T, user_sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_session.
     * @param {user_sessionDeleteArgs} args - Arguments to delete one User_session.
     * @example
     * // Delete one User_session
     * const User_session = await prisma.user_session.delete({
     *   where: {
     *     // ... filter to delete one User_session
     *   }
     * })
     * 
     */
    delete<T extends user_sessionDeleteArgs>(args: SelectSubset<T, user_sessionDeleteArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_session.
     * @param {user_sessionUpdateArgs} args - Arguments to update one User_session.
     * @example
     * // Update one User_session
     * const user_session = await prisma.user_session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_sessionUpdateArgs>(args: SelectSubset<T, user_sessionUpdateArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_sessions.
     * @param {user_sessionDeleteManyArgs} args - Arguments to filter User_sessions to delete.
     * @example
     * // Delete a few User_sessions
     * const { count } = await prisma.user_session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_sessionDeleteManyArgs>(args?: SelectSubset<T, user_sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_sessions
     * const user_session = await prisma.user_session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_sessionUpdateManyArgs>(args: SelectSubset<T, user_sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_session.
     * @param {user_sessionUpsertArgs} args - Arguments to update or create a User_session.
     * @example
     * // Update or create a User_session
     * const user_session = await prisma.user_session.upsert({
     *   create: {
     *     // ... data to create a User_session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_session we want to update
     *   }
     * })
     */
    upsert<T extends user_sessionUpsertArgs>(args: SelectSubset<T, user_sessionUpsertArgs<ExtArgs>>): Prisma__user_sessionClient<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionCountArgs} args - Arguments to filter User_sessions to count.
     * @example
     * // Count the number of User_sessions
     * const count = await prisma.user_session.count({
     *   where: {
     *     // ... the filter for the User_sessions we want to count
     *   }
     * })
    **/
    count<T extends user_sessionCountArgs>(
      args?: Subset<T, user_sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_sessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_sessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_sessionAggregateArgs>(args: Subset<T, User_sessionAggregateArgs>): Prisma.PrismaPromise<GetUser_sessionAggregateType<T>>

    /**
     * Group by User_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_sessionGroupByArgs['orderBy'] }
        : { orderBy?: user_sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_sessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_session model
   */
  readonly fields: user_sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends user_session$usersArgs<ExtArgs> = {}>(args?: Subset<T, user_session$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_session model
   */
  interface user_sessionFieldRefs {
    readonly SESSION_ID: FieldRef<"user_session", 'Int'>
    readonly USER_ID: FieldRef<"user_session", 'Int'>
    readonly SESSION_TOKEN: FieldRef<"user_session", 'String'>
    readonly EXPIRES: FieldRef<"user_session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_session findUnique
   */
  export type user_sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * Filter, which user_session to fetch.
     */
    where: user_sessionWhereUniqueInput
  }

  /**
   * user_session findUniqueOrThrow
   */
  export type user_sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * Filter, which user_session to fetch.
     */
    where: user_sessionWhereUniqueInput
  }

  /**
   * user_session findFirst
   */
  export type user_sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * Filter, which user_session to fetch.
     */
    where?: user_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionOrderByWithRelationInput | user_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_sessions.
     */
    cursor?: user_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_sessions.
     */
    distinct?: User_sessionScalarFieldEnum | User_sessionScalarFieldEnum[]
  }

  /**
   * user_session findFirstOrThrow
   */
  export type user_sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * Filter, which user_session to fetch.
     */
    where?: user_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionOrderByWithRelationInput | user_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_sessions.
     */
    cursor?: user_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_sessions.
     */
    distinct?: User_sessionScalarFieldEnum | User_sessionScalarFieldEnum[]
  }

  /**
   * user_session findMany
   */
  export type user_sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * Filter, which user_sessions to fetch.
     */
    where?: user_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionOrderByWithRelationInput | user_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_sessions.
     */
    cursor?: user_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    distinct?: User_sessionScalarFieldEnum | User_sessionScalarFieldEnum[]
  }

  /**
   * user_session create
   */
  export type user_sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a user_session.
     */
    data: XOR<user_sessionCreateInput, user_sessionUncheckedCreateInput>
  }

  /**
   * user_session createMany
   */
  export type user_sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_sessions.
     */
    data: user_sessionCreateManyInput | user_sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_session update
   */
  export type user_sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a user_session.
     */
    data: XOR<user_sessionUpdateInput, user_sessionUncheckedUpdateInput>
    /**
     * Choose, which user_session to update.
     */
    where: user_sessionWhereUniqueInput
  }

  /**
   * user_session updateMany
   */
  export type user_sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_sessions.
     */
    data: XOR<user_sessionUpdateManyMutationInput, user_sessionUncheckedUpdateManyInput>
    /**
     * Filter which user_sessions to update
     */
    where?: user_sessionWhereInput
    /**
     * Limit how many user_sessions to update.
     */
    limit?: number
  }

  /**
   * user_session upsert
   */
  export type user_sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the user_session to update in case it exists.
     */
    where: user_sessionWhereUniqueInput
    /**
     * In case the user_session found by the `where` argument doesn't exist, create a new user_session with this data.
     */
    create: XOR<user_sessionCreateInput, user_sessionUncheckedCreateInput>
    /**
     * In case the user_session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_sessionUpdateInput, user_sessionUncheckedUpdateInput>
  }

  /**
   * user_session delete
   */
  export type user_sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    /**
     * Filter which user_session to delete.
     */
    where: user_sessionWhereUniqueInput
  }

  /**
   * user_session deleteMany
   */
  export type user_sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_sessions to delete
     */
    where?: user_sessionWhereInput
    /**
     * Limit how many user_sessions to delete.
     */
    limit?: number
  }

  /**
   * user_session.users
   */
  export type user_session$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * user_session without action
   */
  export type user_sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
  }


  /**
   * Model userplaiditem
   */

  export type AggregateUserplaiditem = {
    _count: UserplaiditemCountAggregateOutputType | null
    _min: UserplaiditemMinAggregateOutputType | null
    _max: UserplaiditemMaxAggregateOutputType | null
  }

  export type UserplaiditemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    encryptedAccessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserplaiditemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    encryptedAccessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserplaiditemCountAggregateOutputType = {
    id: number
    userId: number
    itemId: number
    encryptedAccessToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserplaiditemMinAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    encryptedAccessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserplaiditemMaxAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    encryptedAccessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserplaiditemCountAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    encryptedAccessToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserplaiditemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userplaiditem to aggregate.
     */
    where?: userplaiditemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userplaiditems to fetch.
     */
    orderBy?: userplaiditemOrderByWithRelationInput | userplaiditemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userplaiditemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userplaiditems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userplaiditems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userplaiditems
    **/
    _count?: true | UserplaiditemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserplaiditemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserplaiditemMaxAggregateInputType
  }

  export type GetUserplaiditemAggregateType<T extends UserplaiditemAggregateArgs> = {
        [P in keyof T & keyof AggregateUserplaiditem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserplaiditem[P]>
      : GetScalarType<T[P], AggregateUserplaiditem[P]>
  }




  export type userplaiditemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userplaiditemWhereInput
    orderBy?: userplaiditemOrderByWithAggregationInput | userplaiditemOrderByWithAggregationInput[]
    by: UserplaiditemScalarFieldEnum[] | UserplaiditemScalarFieldEnum
    having?: userplaiditemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserplaiditemCountAggregateInputType | true
    _min?: UserplaiditemMinAggregateInputType
    _max?: UserplaiditemMaxAggregateInputType
  }

  export type UserplaiditemGroupByOutputType = {
    id: string
    userId: string
    itemId: string
    encryptedAccessToken: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserplaiditemCountAggregateOutputType | null
    _min: UserplaiditemMinAggregateOutputType | null
    _max: UserplaiditemMaxAggregateOutputType | null
  }

  type GetUserplaiditemGroupByPayload<T extends userplaiditemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserplaiditemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserplaiditemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserplaiditemGroupByOutputType[P]>
            : GetScalarType<T[P], UserplaiditemGroupByOutputType[P]>
        }
      >
    >


  export type userplaiditemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    encryptedAccessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userplaiditem"]>



  export type userplaiditemSelectScalar = {
    id?: boolean
    userId?: boolean
    itemId?: boolean
    encryptedAccessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userplaiditemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "itemId" | "encryptedAccessToken" | "createdAt" | "updatedAt", ExtArgs["result"]["userplaiditem"]>

  export type $userplaiditemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userplaiditem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemId: string
      encryptedAccessToken: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["userplaiditem"]>
    composites: {}
  }

  type userplaiditemGetPayload<S extends boolean | null | undefined | userplaiditemDefaultArgs> = $Result.GetResult<Prisma.$userplaiditemPayload, S>

  type userplaiditemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userplaiditemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserplaiditemCountAggregateInputType | true
    }

  export interface userplaiditemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userplaiditem'], meta: { name: 'userplaiditem' } }
    /**
     * Find zero or one Userplaiditem that matches the filter.
     * @param {userplaiditemFindUniqueArgs} args - Arguments to find a Userplaiditem
     * @example
     * // Get one Userplaiditem
     * const userplaiditem = await prisma.userplaiditem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userplaiditemFindUniqueArgs>(args: SelectSubset<T, userplaiditemFindUniqueArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userplaiditem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userplaiditemFindUniqueOrThrowArgs} args - Arguments to find a Userplaiditem
     * @example
     * // Get one Userplaiditem
     * const userplaiditem = await prisma.userplaiditem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userplaiditemFindUniqueOrThrowArgs>(args: SelectSubset<T, userplaiditemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userplaiditem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userplaiditemFindFirstArgs} args - Arguments to find a Userplaiditem
     * @example
     * // Get one Userplaiditem
     * const userplaiditem = await prisma.userplaiditem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userplaiditemFindFirstArgs>(args?: SelectSubset<T, userplaiditemFindFirstArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userplaiditem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userplaiditemFindFirstOrThrowArgs} args - Arguments to find a Userplaiditem
     * @example
     * // Get one Userplaiditem
     * const userplaiditem = await prisma.userplaiditem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userplaiditemFindFirstOrThrowArgs>(args?: SelectSubset<T, userplaiditemFindFirstOrThrowArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userplaiditems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userplaiditemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userplaiditems
     * const userplaiditems = await prisma.userplaiditem.findMany()
     * 
     * // Get first 10 Userplaiditems
     * const userplaiditems = await prisma.userplaiditem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userplaiditemWithIdOnly = await prisma.userplaiditem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userplaiditemFindManyArgs>(args?: SelectSubset<T, userplaiditemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userplaiditem.
     * @param {userplaiditemCreateArgs} args - Arguments to create a Userplaiditem.
     * @example
     * // Create one Userplaiditem
     * const Userplaiditem = await prisma.userplaiditem.create({
     *   data: {
     *     // ... data to create a Userplaiditem
     *   }
     * })
     * 
     */
    create<T extends userplaiditemCreateArgs>(args: SelectSubset<T, userplaiditemCreateArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userplaiditems.
     * @param {userplaiditemCreateManyArgs} args - Arguments to create many Userplaiditems.
     * @example
     * // Create many Userplaiditems
     * const userplaiditem = await prisma.userplaiditem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userplaiditemCreateManyArgs>(args?: SelectSubset<T, userplaiditemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userplaiditem.
     * @param {userplaiditemDeleteArgs} args - Arguments to delete one Userplaiditem.
     * @example
     * // Delete one Userplaiditem
     * const Userplaiditem = await prisma.userplaiditem.delete({
     *   where: {
     *     // ... filter to delete one Userplaiditem
     *   }
     * })
     * 
     */
    delete<T extends userplaiditemDeleteArgs>(args: SelectSubset<T, userplaiditemDeleteArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userplaiditem.
     * @param {userplaiditemUpdateArgs} args - Arguments to update one Userplaiditem.
     * @example
     * // Update one Userplaiditem
     * const userplaiditem = await prisma.userplaiditem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userplaiditemUpdateArgs>(args: SelectSubset<T, userplaiditemUpdateArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userplaiditems.
     * @param {userplaiditemDeleteManyArgs} args - Arguments to filter Userplaiditems to delete.
     * @example
     * // Delete a few Userplaiditems
     * const { count } = await prisma.userplaiditem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userplaiditemDeleteManyArgs>(args?: SelectSubset<T, userplaiditemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userplaiditems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userplaiditemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userplaiditems
     * const userplaiditem = await prisma.userplaiditem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userplaiditemUpdateManyArgs>(args: SelectSubset<T, userplaiditemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userplaiditem.
     * @param {userplaiditemUpsertArgs} args - Arguments to update or create a Userplaiditem.
     * @example
     * // Update or create a Userplaiditem
     * const userplaiditem = await prisma.userplaiditem.upsert({
     *   create: {
     *     // ... data to create a Userplaiditem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userplaiditem we want to update
     *   }
     * })
     */
    upsert<T extends userplaiditemUpsertArgs>(args: SelectSubset<T, userplaiditemUpsertArgs<ExtArgs>>): Prisma__userplaiditemClient<$Result.GetResult<Prisma.$userplaiditemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userplaiditems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userplaiditemCountArgs} args - Arguments to filter Userplaiditems to count.
     * @example
     * // Count the number of Userplaiditems
     * const count = await prisma.userplaiditem.count({
     *   where: {
     *     // ... the filter for the Userplaiditems we want to count
     *   }
     * })
    **/
    count<T extends userplaiditemCountArgs>(
      args?: Subset<T, userplaiditemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserplaiditemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userplaiditem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserplaiditemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserplaiditemAggregateArgs>(args: Subset<T, UserplaiditemAggregateArgs>): Prisma.PrismaPromise<GetUserplaiditemAggregateType<T>>

    /**
     * Group by Userplaiditem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userplaiditemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userplaiditemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userplaiditemGroupByArgs['orderBy'] }
        : { orderBy?: userplaiditemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userplaiditemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserplaiditemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userplaiditem model
   */
  readonly fields: userplaiditemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userplaiditem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userplaiditemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userplaiditem model
   */
  interface userplaiditemFieldRefs {
    readonly id: FieldRef<"userplaiditem", 'String'>
    readonly userId: FieldRef<"userplaiditem", 'String'>
    readonly itemId: FieldRef<"userplaiditem", 'String'>
    readonly encryptedAccessToken: FieldRef<"userplaiditem", 'String'>
    readonly createdAt: FieldRef<"userplaiditem", 'DateTime'>
    readonly updatedAt: FieldRef<"userplaiditem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userplaiditem findUnique
   */
  export type userplaiditemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * Filter, which userplaiditem to fetch.
     */
    where: userplaiditemWhereUniqueInput
  }

  /**
   * userplaiditem findUniqueOrThrow
   */
  export type userplaiditemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * Filter, which userplaiditem to fetch.
     */
    where: userplaiditemWhereUniqueInput
  }

  /**
   * userplaiditem findFirst
   */
  export type userplaiditemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * Filter, which userplaiditem to fetch.
     */
    where?: userplaiditemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userplaiditems to fetch.
     */
    orderBy?: userplaiditemOrderByWithRelationInput | userplaiditemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userplaiditems.
     */
    cursor?: userplaiditemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userplaiditems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userplaiditems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userplaiditems.
     */
    distinct?: UserplaiditemScalarFieldEnum | UserplaiditemScalarFieldEnum[]
  }

  /**
   * userplaiditem findFirstOrThrow
   */
  export type userplaiditemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * Filter, which userplaiditem to fetch.
     */
    where?: userplaiditemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userplaiditems to fetch.
     */
    orderBy?: userplaiditemOrderByWithRelationInput | userplaiditemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userplaiditems.
     */
    cursor?: userplaiditemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userplaiditems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userplaiditems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userplaiditems.
     */
    distinct?: UserplaiditemScalarFieldEnum | UserplaiditemScalarFieldEnum[]
  }

  /**
   * userplaiditem findMany
   */
  export type userplaiditemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * Filter, which userplaiditems to fetch.
     */
    where?: userplaiditemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userplaiditems to fetch.
     */
    orderBy?: userplaiditemOrderByWithRelationInput | userplaiditemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userplaiditems.
     */
    cursor?: userplaiditemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userplaiditems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userplaiditems.
     */
    skip?: number
    distinct?: UserplaiditemScalarFieldEnum | UserplaiditemScalarFieldEnum[]
  }

  /**
   * userplaiditem create
   */
  export type userplaiditemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * The data needed to create a userplaiditem.
     */
    data: XOR<userplaiditemCreateInput, userplaiditemUncheckedCreateInput>
  }

  /**
   * userplaiditem createMany
   */
  export type userplaiditemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userplaiditems.
     */
    data: userplaiditemCreateManyInput | userplaiditemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userplaiditem update
   */
  export type userplaiditemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * The data needed to update a userplaiditem.
     */
    data: XOR<userplaiditemUpdateInput, userplaiditemUncheckedUpdateInput>
    /**
     * Choose, which userplaiditem to update.
     */
    where: userplaiditemWhereUniqueInput
  }

  /**
   * userplaiditem updateMany
   */
  export type userplaiditemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userplaiditems.
     */
    data: XOR<userplaiditemUpdateManyMutationInput, userplaiditemUncheckedUpdateManyInput>
    /**
     * Filter which userplaiditems to update
     */
    where?: userplaiditemWhereInput
    /**
     * Limit how many userplaiditems to update.
     */
    limit?: number
  }

  /**
   * userplaiditem upsert
   */
  export type userplaiditemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * The filter to search for the userplaiditem to update in case it exists.
     */
    where: userplaiditemWhereUniqueInput
    /**
     * In case the userplaiditem found by the `where` argument doesn't exist, create a new userplaiditem with this data.
     */
    create: XOR<userplaiditemCreateInput, userplaiditemUncheckedCreateInput>
    /**
     * In case the userplaiditem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userplaiditemUpdateInput, userplaiditemUncheckedUpdateInput>
  }

  /**
   * userplaiditem delete
   */
  export type userplaiditemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
    /**
     * Filter which userplaiditem to delete.
     */
    where: userplaiditemWhereUniqueInput
  }

  /**
   * userplaiditem deleteMany
   */
  export type userplaiditemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userplaiditems to delete
     */
    where?: userplaiditemWhereInput
    /**
     * Limit how many userplaiditems to delete.
     */
    limit?: number
  }

  /**
   * userplaiditem without action
   */
  export type userplaiditemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userplaiditem
     */
    select?: userplaiditemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userplaiditem
     */
    omit?: userplaiditemOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    USER_ID: number | null
  }

  export type UsersSumAggregateOutputType = {
    USER_ID: number | null
  }

  export type UsersMinAggregateOutputType = {
    USER_ID: number | null
    PASS: string | null
    USER_LNAME: string | null
    USER_FNAME: string | null
    STREET: string | null
    CITY: string | null
    STATE: string | null
    ZIP: string | null
    GENDER: string | null
    PHONE: string | null
    EMAIL: string | null
  }

  export type UsersMaxAggregateOutputType = {
    USER_ID: number | null
    PASS: string | null
    USER_LNAME: string | null
    USER_FNAME: string | null
    STREET: string | null
    CITY: string | null
    STATE: string | null
    ZIP: string | null
    GENDER: string | null
    PHONE: string | null
    EMAIL: string | null
  }

  export type UsersCountAggregateOutputType = {
    USER_ID: number
    PASS: number
    USER_LNAME: number
    USER_FNAME: number
    STREET: number
    CITY: number
    STATE: number
    ZIP: number
    GENDER: number
    PHONE: number
    EMAIL: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    USER_ID?: true
  }

  export type UsersSumAggregateInputType = {
    USER_ID?: true
  }

  export type UsersMinAggregateInputType = {
    USER_ID?: true
    PASS?: true
    USER_LNAME?: true
    USER_FNAME?: true
    STREET?: true
    CITY?: true
    STATE?: true
    ZIP?: true
    GENDER?: true
    PHONE?: true
    EMAIL?: true
  }

  export type UsersMaxAggregateInputType = {
    USER_ID?: true
    PASS?: true
    USER_LNAME?: true
    USER_FNAME?: true
    STREET?: true
    CITY?: true
    STATE?: true
    ZIP?: true
    GENDER?: true
    PHONE?: true
    EMAIL?: true
  }

  export type UsersCountAggregateInputType = {
    USER_ID?: true
    PASS?: true
    USER_LNAME?: true
    USER_FNAME?: true
    STREET?: true
    CITY?: true
    STATE?: true
    ZIP?: true
    GENDER?: true
    PHONE?: true
    EMAIL?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    USER_ID: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET: string | null
    CITY: string | null
    STATE: string | null
    ZIP: string | null
    GENDER: string | null
    PHONE: string | null
    EMAIL: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    USER_ID?: boolean
    PASS?: boolean
    USER_LNAME?: boolean
    USER_FNAME?: boolean
    STREET?: boolean
    CITY?: boolean
    STATE?: boolean
    ZIP?: boolean
    GENDER?: boolean
    PHONE?: boolean
    EMAIL?: boolean
    credit_cards?: boolean | users$credit_cardsArgs<ExtArgs>
    payment_plan?: boolean | users$payment_planArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    security_log?: boolean | users$security_logArgs<ExtArgs>
    settlements?: boolean | users$settlementsArgs<ExtArgs>
    user_session?: boolean | users$user_sessionArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    USER_ID?: boolean
    PASS?: boolean
    USER_LNAME?: boolean
    USER_FNAME?: boolean
    STREET?: boolean
    CITY?: boolean
    STATE?: boolean
    ZIP?: boolean
    GENDER?: boolean
    PHONE?: boolean
    EMAIL?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"USER_ID" | "PASS" | "USER_LNAME" | "USER_FNAME" | "STREET" | "CITY" | "STATE" | "ZIP" | "GENDER" | "PHONE" | "EMAIL", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_cards?: boolean | users$credit_cardsArgs<ExtArgs>
    payment_plan?: boolean | users$payment_planArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    security_log?: boolean | users$security_logArgs<ExtArgs>
    settlements?: boolean | users$settlementsArgs<ExtArgs>
    user_session?: boolean | users$user_sessionArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      credit_cards: Prisma.$credit_cardsPayload<ExtArgs>[]
      payment_plan: Prisma.$payment_planPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      security_log: Prisma.$security_logPayload<ExtArgs>[]
      settlements: Prisma.$settlementsPayload<ExtArgs>[]
      user_session: Prisma.$user_sessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      USER_ID: number
      PASS: string
      USER_LNAME: string
      USER_FNAME: string
      STREET: string | null
      CITY: string | null
      STATE: string | null
      ZIP: string | null
      GENDER: string | null
      PHONE: string | null
      EMAIL: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `USER_ID`
     * const usersWithUSER_IDOnly = await prisma.users.findMany({ select: { USER_ID: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credit_cards<T extends users$credit_cardsArgs<ExtArgs> = {}>(args?: Subset<T, users$credit_cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_plan<T extends users$payment_planArgs<ExtArgs> = {}>(args?: Subset<T, users$payment_planArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends users$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, users$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    security_log<T extends users$security_logArgs<ExtArgs> = {}>(args?: Subset<T, users$security_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$security_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settlements<T extends users$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, users$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settlementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_session<T extends users$user_sessionArgs<ExtArgs> = {}>(args?: Subset<T, users$user_sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly USER_ID: FieldRef<"users", 'Int'>
    readonly PASS: FieldRef<"users", 'String'>
    readonly USER_LNAME: FieldRef<"users", 'String'>
    readonly USER_FNAME: FieldRef<"users", 'String'>
    readonly STREET: FieldRef<"users", 'String'>
    readonly CITY: FieldRef<"users", 'String'>
    readonly STATE: FieldRef<"users", 'String'>
    readonly ZIP: FieldRef<"users", 'String'>
    readonly GENDER: FieldRef<"users", 'String'>
    readonly PHONE: FieldRef<"users", 'String'>
    readonly EMAIL: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.credit_cards
   */
  export type users$credit_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_cardsInclude<ExtArgs> | null
    where?: credit_cardsWhereInput
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    cursor?: credit_cardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Credit_cardsScalarFieldEnum | Credit_cardsScalarFieldEnum[]
  }

  /**
   * users.payment_plan
   */
  export type users$payment_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_plan
     */
    select?: payment_planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_plan
     */
    omit?: payment_planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_planInclude<ExtArgs> | null
    where?: payment_planWhereInput
    orderBy?: payment_planOrderByWithRelationInput | payment_planOrderByWithRelationInput[]
    cursor?: payment_planWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_planScalarFieldEnum | Payment_planScalarFieldEnum[]
  }

  /**
   * users.payments
   */
  export type users$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * users.security_log
   */
  export type users$security_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_log
     */
    select?: security_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_log
     */
    omit?: security_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_logInclude<ExtArgs> | null
    where?: security_logWhereInput
    orderBy?: security_logOrderByWithRelationInput | security_logOrderByWithRelationInput[]
    cursor?: security_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Security_logScalarFieldEnum | Security_logScalarFieldEnum[]
  }

  /**
   * users.settlements
   */
  export type users$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlements
     */
    select?: settlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlements
     */
    omit?: settlementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settlementsInclude<ExtArgs> | null
    where?: settlementsWhereInput
    orderBy?: settlementsOrderByWithRelationInput | settlementsOrderByWithRelationInput[]
    cursor?: settlementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettlementsScalarFieldEnum | SettlementsScalarFieldEnum[]
  }

  /**
   * users.user_session
   */
  export type users$user_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_session
     */
    select?: user_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_session
     */
    omit?: user_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionInclude<ExtArgs> | null
    where?: user_sessionWhereInput
    orderBy?: user_sessionOrderByWithRelationInput | user_sessionOrderByWithRelationInput[]
    cursor?: user_sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_sessionScalarFieldEnum | User_sessionScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model debt_payment
   */

  export type AggregateDebt_payment = {
    _count: Debt_paymentCountAggregateOutputType | null
    _avg: Debt_paymentAvgAggregateOutputType | null
    _sum: Debt_paymentSumAggregateOutputType | null
    _min: Debt_paymentMinAggregateOutputType | null
    _max: Debt_paymentMaxAggregateOutputType | null
  }

  export type Debt_paymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type Debt_paymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type Debt_paymentMinAggregateOutputType = {
    id: string | null
    debtId: string | null
    userId: string | null
    amount: Decimal | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Debt_paymentMaxAggregateOutputType = {
    id: string | null
    debtId: string | null
    userId: string | null
    amount: Decimal | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Debt_paymentCountAggregateOutputType = {
    id: number
    debtId: number
    userId: number
    amount: number
    date: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Debt_paymentAvgAggregateInputType = {
    amount?: true
  }

  export type Debt_paymentSumAggregateInputType = {
    amount?: true
  }

  export type Debt_paymentMinAggregateInputType = {
    id?: true
    debtId?: true
    userId?: true
    amount?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Debt_paymentMaxAggregateInputType = {
    id?: true
    debtId?: true
    userId?: true
    amount?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Debt_paymentCountAggregateInputType = {
    id?: true
    debtId?: true
    userId?: true
    amount?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Debt_paymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which debt_payment to aggregate.
     */
    where?: debt_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debt_payments to fetch.
     */
    orderBy?: debt_paymentOrderByWithRelationInput | debt_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: debt_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debt_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debt_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned debt_payments
    **/
    _count?: true | Debt_paymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Debt_paymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Debt_paymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Debt_paymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Debt_paymentMaxAggregateInputType
  }

  export type GetDebt_paymentAggregateType<T extends Debt_paymentAggregateArgs> = {
        [P in keyof T & keyof AggregateDebt_payment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebt_payment[P]>
      : GetScalarType<T[P], AggregateDebt_payment[P]>
  }




  export type debt_paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: debt_paymentWhereInput
    orderBy?: debt_paymentOrderByWithAggregationInput | debt_paymentOrderByWithAggregationInput[]
    by: Debt_paymentScalarFieldEnum[] | Debt_paymentScalarFieldEnum
    having?: debt_paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Debt_paymentCountAggregateInputType | true
    _avg?: Debt_paymentAvgAggregateInputType
    _sum?: Debt_paymentSumAggregateInputType
    _min?: Debt_paymentMinAggregateInputType
    _max?: Debt_paymentMaxAggregateInputType
  }

  export type Debt_paymentGroupByOutputType = {
    id: string
    debtId: string
    userId: string
    amount: Decimal
    date: Date
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: Debt_paymentCountAggregateOutputType | null
    _avg: Debt_paymentAvgAggregateOutputType | null
    _sum: Debt_paymentSumAggregateOutputType | null
    _min: Debt_paymentMinAggregateOutputType | null
    _max: Debt_paymentMaxAggregateOutputType | null
  }

  type GetDebt_paymentGroupByPayload<T extends debt_paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Debt_paymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Debt_paymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Debt_paymentGroupByOutputType[P]>
            : GetScalarType<T[P], Debt_paymentGroupByOutputType[P]>
        }
      >
    >


  export type debt_paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtId?: boolean
    userId?: boolean
    amount?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debt?: boolean | debtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debt_payment"]>



  export type debt_paymentSelectScalar = {
    id?: boolean
    debtId?: boolean
    userId?: boolean
    amount?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type debt_paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "debtId" | "userId" | "amount" | "date" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["debt_payment"]>
  export type debt_paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debt?: boolean | debtDefaultArgs<ExtArgs>
  }

  export type $debt_paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "debt_payment"
    objects: {
      debt: Prisma.$debtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      debtId: string
      userId: string
      amount: Prisma.Decimal
      date: Date
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["debt_payment"]>
    composites: {}
  }

  type debt_paymentGetPayload<S extends boolean | null | undefined | debt_paymentDefaultArgs> = $Result.GetResult<Prisma.$debt_paymentPayload, S>

  type debt_paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<debt_paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Debt_paymentCountAggregateInputType | true
    }

  export interface debt_paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['debt_payment'], meta: { name: 'debt_payment' } }
    /**
     * Find zero or one Debt_payment that matches the filter.
     * @param {debt_paymentFindUniqueArgs} args - Arguments to find a Debt_payment
     * @example
     * // Get one Debt_payment
     * const debt_payment = await prisma.debt_payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends debt_paymentFindUniqueArgs>(args: SelectSubset<T, debt_paymentFindUniqueArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Debt_payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {debt_paymentFindUniqueOrThrowArgs} args - Arguments to find a Debt_payment
     * @example
     * // Get one Debt_payment
     * const debt_payment = await prisma.debt_payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends debt_paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, debt_paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt_payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debt_paymentFindFirstArgs} args - Arguments to find a Debt_payment
     * @example
     * // Get one Debt_payment
     * const debt_payment = await prisma.debt_payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends debt_paymentFindFirstArgs>(args?: SelectSubset<T, debt_paymentFindFirstArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt_payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debt_paymentFindFirstOrThrowArgs} args - Arguments to find a Debt_payment
     * @example
     * // Get one Debt_payment
     * const debt_payment = await prisma.debt_payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends debt_paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, debt_paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debt_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debt_paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debt_payments
     * const debt_payments = await prisma.debt_payment.findMany()
     * 
     * // Get first 10 Debt_payments
     * const debt_payments = await prisma.debt_payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debt_paymentWithIdOnly = await prisma.debt_payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends debt_paymentFindManyArgs>(args?: SelectSubset<T, debt_paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Debt_payment.
     * @param {debt_paymentCreateArgs} args - Arguments to create a Debt_payment.
     * @example
     * // Create one Debt_payment
     * const Debt_payment = await prisma.debt_payment.create({
     *   data: {
     *     // ... data to create a Debt_payment
     *   }
     * })
     * 
     */
    create<T extends debt_paymentCreateArgs>(args: SelectSubset<T, debt_paymentCreateArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Debt_payments.
     * @param {debt_paymentCreateManyArgs} args - Arguments to create many Debt_payments.
     * @example
     * // Create many Debt_payments
     * const debt_payment = await prisma.debt_payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends debt_paymentCreateManyArgs>(args?: SelectSubset<T, debt_paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Debt_payment.
     * @param {debt_paymentDeleteArgs} args - Arguments to delete one Debt_payment.
     * @example
     * // Delete one Debt_payment
     * const Debt_payment = await prisma.debt_payment.delete({
     *   where: {
     *     // ... filter to delete one Debt_payment
     *   }
     * })
     * 
     */
    delete<T extends debt_paymentDeleteArgs>(args: SelectSubset<T, debt_paymentDeleteArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Debt_payment.
     * @param {debt_paymentUpdateArgs} args - Arguments to update one Debt_payment.
     * @example
     * // Update one Debt_payment
     * const debt_payment = await prisma.debt_payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends debt_paymentUpdateArgs>(args: SelectSubset<T, debt_paymentUpdateArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Debt_payments.
     * @param {debt_paymentDeleteManyArgs} args - Arguments to filter Debt_payments to delete.
     * @example
     * // Delete a few Debt_payments
     * const { count } = await prisma.debt_payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends debt_paymentDeleteManyArgs>(args?: SelectSubset<T, debt_paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debt_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debt_paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debt_payments
     * const debt_payment = await prisma.debt_payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends debt_paymentUpdateManyArgs>(args: SelectSubset<T, debt_paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Debt_payment.
     * @param {debt_paymentUpsertArgs} args - Arguments to update or create a Debt_payment.
     * @example
     * // Update or create a Debt_payment
     * const debt_payment = await prisma.debt_payment.upsert({
     *   create: {
     *     // ... data to create a Debt_payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debt_payment we want to update
     *   }
     * })
     */
    upsert<T extends debt_paymentUpsertArgs>(args: SelectSubset<T, debt_paymentUpsertArgs<ExtArgs>>): Prisma__debt_paymentClient<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Debt_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debt_paymentCountArgs} args - Arguments to filter Debt_payments to count.
     * @example
     * // Count the number of Debt_payments
     * const count = await prisma.debt_payment.count({
     *   where: {
     *     // ... the filter for the Debt_payments we want to count
     *   }
     * })
    **/
    count<T extends debt_paymentCountArgs>(
      args?: Subset<T, debt_paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Debt_paymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debt_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Debt_paymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Debt_paymentAggregateArgs>(args: Subset<T, Debt_paymentAggregateArgs>): Prisma.PrismaPromise<GetDebt_paymentAggregateType<T>>

    /**
     * Group by Debt_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debt_paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends debt_paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: debt_paymentGroupByArgs['orderBy'] }
        : { orderBy?: debt_paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, debt_paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebt_paymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the debt_payment model
   */
  readonly fields: debt_paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for debt_payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__debt_paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debt<T extends debtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, debtDefaultArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the debt_payment model
   */
  interface debt_paymentFieldRefs {
    readonly id: FieldRef<"debt_payment", 'String'>
    readonly debtId: FieldRef<"debt_payment", 'String'>
    readonly userId: FieldRef<"debt_payment", 'String'>
    readonly amount: FieldRef<"debt_payment", 'Decimal'>
    readonly date: FieldRef<"debt_payment", 'DateTime'>
    readonly notes: FieldRef<"debt_payment", 'String'>
    readonly createdAt: FieldRef<"debt_payment", 'DateTime'>
    readonly updatedAt: FieldRef<"debt_payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * debt_payment findUnique
   */
  export type debt_paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * Filter, which debt_payment to fetch.
     */
    where: debt_paymentWhereUniqueInput
  }

  /**
   * debt_payment findUniqueOrThrow
   */
  export type debt_paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * Filter, which debt_payment to fetch.
     */
    where: debt_paymentWhereUniqueInput
  }

  /**
   * debt_payment findFirst
   */
  export type debt_paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * Filter, which debt_payment to fetch.
     */
    where?: debt_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debt_payments to fetch.
     */
    orderBy?: debt_paymentOrderByWithRelationInput | debt_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for debt_payments.
     */
    cursor?: debt_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debt_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debt_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of debt_payments.
     */
    distinct?: Debt_paymentScalarFieldEnum | Debt_paymentScalarFieldEnum[]
  }

  /**
   * debt_payment findFirstOrThrow
   */
  export type debt_paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * Filter, which debt_payment to fetch.
     */
    where?: debt_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debt_payments to fetch.
     */
    orderBy?: debt_paymentOrderByWithRelationInput | debt_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for debt_payments.
     */
    cursor?: debt_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debt_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debt_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of debt_payments.
     */
    distinct?: Debt_paymentScalarFieldEnum | Debt_paymentScalarFieldEnum[]
  }

  /**
   * debt_payment findMany
   */
  export type debt_paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * Filter, which debt_payments to fetch.
     */
    where?: debt_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debt_payments to fetch.
     */
    orderBy?: debt_paymentOrderByWithRelationInput | debt_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing debt_payments.
     */
    cursor?: debt_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debt_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debt_payments.
     */
    skip?: number
    distinct?: Debt_paymentScalarFieldEnum | Debt_paymentScalarFieldEnum[]
  }

  /**
   * debt_payment create
   */
  export type debt_paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a debt_payment.
     */
    data: XOR<debt_paymentCreateInput, debt_paymentUncheckedCreateInput>
  }

  /**
   * debt_payment createMany
   */
  export type debt_paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many debt_payments.
     */
    data: debt_paymentCreateManyInput | debt_paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * debt_payment update
   */
  export type debt_paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a debt_payment.
     */
    data: XOR<debt_paymentUpdateInput, debt_paymentUncheckedUpdateInput>
    /**
     * Choose, which debt_payment to update.
     */
    where: debt_paymentWhereUniqueInput
  }

  /**
   * debt_payment updateMany
   */
  export type debt_paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update debt_payments.
     */
    data: XOR<debt_paymentUpdateManyMutationInput, debt_paymentUncheckedUpdateManyInput>
    /**
     * Filter which debt_payments to update
     */
    where?: debt_paymentWhereInput
    /**
     * Limit how many debt_payments to update.
     */
    limit?: number
  }

  /**
   * debt_payment upsert
   */
  export type debt_paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the debt_payment to update in case it exists.
     */
    where: debt_paymentWhereUniqueInput
    /**
     * In case the debt_payment found by the `where` argument doesn't exist, create a new debt_payment with this data.
     */
    create: XOR<debt_paymentCreateInput, debt_paymentUncheckedCreateInput>
    /**
     * In case the debt_payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<debt_paymentUpdateInput, debt_paymentUncheckedUpdateInput>
  }

  /**
   * debt_payment delete
   */
  export type debt_paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    /**
     * Filter which debt_payment to delete.
     */
    where: debt_paymentWhereUniqueInput
  }

  /**
   * debt_payment deleteMany
   */
  export type debt_paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which debt_payments to delete
     */
    where?: debt_paymentWhereInput
    /**
     * Limit how many debt_payments to delete.
     */
    limit?: number
  }

  /**
   * debt_payment without action
   */
  export type debt_paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
  }


  /**
   * Model debt
   */

  export type AggregateDebt = {
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  export type DebtAvgAggregateOutputType = {
    balance: Decimal | null
    currentBalance: Decimal | null
    interestRate: Decimal | null
    minimumPayment: Decimal | null
    extraPayment: Decimal | null
  }

  export type DebtSumAggregateOutputType = {
    balance: Decimal | null
    currentBalance: Decimal | null
    interestRate: Decimal | null
    minimumPayment: Decimal | null
    extraPayment: Decimal | null
  }

  export type DebtMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    balance: Decimal | null
    currentBalance: Decimal | null
    interestRate: Decimal | null
    minimumPayment: Decimal | null
    dueDate: Date | null
    extraPayment: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    balance: Decimal | null
    currentBalance: Decimal | null
    interestRate: Decimal | null
    minimumPayment: Decimal | null
    dueDate: Date | null
    extraPayment: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    balance: number
    currentBalance: number
    interestRate: number
    minimumPayment: number
    dueDate: number
    extraPayment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DebtAvgAggregateInputType = {
    balance?: true
    currentBalance?: true
    interestRate?: true
    minimumPayment?: true
    extraPayment?: true
  }

  export type DebtSumAggregateInputType = {
    balance?: true
    currentBalance?: true
    interestRate?: true
    minimumPayment?: true
    extraPayment?: true
  }

  export type DebtMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    balance?: true
    currentBalance?: true
    interestRate?: true
    minimumPayment?: true
    dueDate?: true
    extraPayment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    balance?: true
    currentBalance?: true
    interestRate?: true
    minimumPayment?: true
    dueDate?: true
    extraPayment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    balance?: true
    currentBalance?: true
    interestRate?: true
    minimumPayment?: true
    dueDate?: true
    extraPayment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DebtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which debt to aggregate.
     */
    where?: debtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debts to fetch.
     */
    orderBy?: debtOrderByWithRelationInput | debtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: debtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned debts
    **/
    _count?: true | DebtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtMaxAggregateInputType
  }

  export type GetDebtAggregateType<T extends DebtAggregateArgs> = {
        [P in keyof T & keyof AggregateDebt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebt[P]>
      : GetScalarType<T[P], AggregateDebt[P]>
  }




  export type debtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: debtWhereInput
    orderBy?: debtOrderByWithAggregationInput | debtOrderByWithAggregationInput[]
    by: DebtScalarFieldEnum[] | DebtScalarFieldEnum
    having?: debtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtCountAggregateInputType | true
    _avg?: DebtAvgAggregateInputType
    _sum?: DebtSumAggregateInputType
    _min?: DebtMinAggregateInputType
    _max?: DebtMaxAggregateInputType
  }

  export type DebtGroupByOutputType = {
    id: string
    userId: string
    name: string
    balance: Decimal
    currentBalance: Decimal
    interestRate: Decimal
    minimumPayment: Decimal
    dueDate: Date
    extraPayment: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  type GetDebtGroupByPayload<T extends debtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtGroupByOutputType[P]>
            : GetScalarType<T[P], DebtGroupByOutputType[P]>
        }
      >
    >


  export type debtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    balance?: boolean
    currentBalance?: boolean
    interestRate?: boolean
    minimumPayment?: boolean
    dueDate?: boolean
    extraPayment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payments?: boolean | debt$paymentsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debt"]>



  export type debtSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    balance?: boolean
    currentBalance?: boolean
    interestRate?: boolean
    minimumPayment?: boolean
    dueDate?: boolean
    extraPayment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type debtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "balance" | "currentBalance" | "interestRate" | "minimumPayment" | "dueDate" | "extraPayment" | "createdAt" | "updatedAt", ExtArgs["result"]["debt"]>
  export type debtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | debt$paymentsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $debtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "debt"
    objects: {
      payments: Prisma.$debt_paymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      balance: Prisma.Decimal
      currentBalance: Prisma.Decimal
      interestRate: Prisma.Decimal
      minimumPayment: Prisma.Decimal
      dueDate: Date
      extraPayment: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["debt"]>
    composites: {}
  }

  type debtGetPayload<S extends boolean | null | undefined | debtDefaultArgs> = $Result.GetResult<Prisma.$debtPayload, S>

  type debtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<debtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtCountAggregateInputType | true
    }

  export interface debtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['debt'], meta: { name: 'debt' } }
    /**
     * Find zero or one Debt that matches the filter.
     * @param {debtFindUniqueArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends debtFindUniqueArgs>(args: SelectSubset<T, debtFindUniqueArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Debt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {debtFindUniqueOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends debtFindUniqueOrThrowArgs>(args: SelectSubset<T, debtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debtFindFirstArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends debtFindFirstArgs>(args?: SelectSubset<T, debtFindFirstArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debtFindFirstOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends debtFindFirstOrThrowArgs>(args?: SelectSubset<T, debtFindFirstOrThrowArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debts
     * const debts = await prisma.debt.findMany()
     * 
     * // Get first 10 Debts
     * const debts = await prisma.debt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtWithIdOnly = await prisma.debt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends debtFindManyArgs>(args?: SelectSubset<T, debtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Debt.
     * @param {debtCreateArgs} args - Arguments to create a Debt.
     * @example
     * // Create one Debt
     * const Debt = await prisma.debt.create({
     *   data: {
     *     // ... data to create a Debt
     *   }
     * })
     * 
     */
    create<T extends debtCreateArgs>(args: SelectSubset<T, debtCreateArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Debts.
     * @param {debtCreateManyArgs} args - Arguments to create many Debts.
     * @example
     * // Create many Debts
     * const debt = await prisma.debt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends debtCreateManyArgs>(args?: SelectSubset<T, debtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Debt.
     * @param {debtDeleteArgs} args - Arguments to delete one Debt.
     * @example
     * // Delete one Debt
     * const Debt = await prisma.debt.delete({
     *   where: {
     *     // ... filter to delete one Debt
     *   }
     * })
     * 
     */
    delete<T extends debtDeleteArgs>(args: SelectSubset<T, debtDeleteArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Debt.
     * @param {debtUpdateArgs} args - Arguments to update one Debt.
     * @example
     * // Update one Debt
     * const debt = await prisma.debt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends debtUpdateArgs>(args: SelectSubset<T, debtUpdateArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Debts.
     * @param {debtDeleteManyArgs} args - Arguments to filter Debts to delete.
     * @example
     * // Delete a few Debts
     * const { count } = await prisma.debt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends debtDeleteManyArgs>(args?: SelectSubset<T, debtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debts
     * const debt = await prisma.debt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends debtUpdateManyArgs>(args: SelectSubset<T, debtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Debt.
     * @param {debtUpsertArgs} args - Arguments to update or create a Debt.
     * @example
     * // Update or create a Debt
     * const debt = await prisma.debt.upsert({
     *   create: {
     *     // ... data to create a Debt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debt we want to update
     *   }
     * })
     */
    upsert<T extends debtUpsertArgs>(args: SelectSubset<T, debtUpsertArgs<ExtArgs>>): Prisma__debtClient<$Result.GetResult<Prisma.$debtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debtCountArgs} args - Arguments to filter Debts to count.
     * @example
     * // Count the number of Debts
     * const count = await prisma.debt.count({
     *   where: {
     *     // ... the filter for the Debts we want to count
     *   }
     * })
    **/
    count<T extends debtCountArgs>(
      args?: Subset<T, debtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtAggregateArgs>(args: Subset<T, DebtAggregateArgs>): Prisma.PrismaPromise<GetDebtAggregateType<T>>

    /**
     * Group by Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends debtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: debtGroupByArgs['orderBy'] }
        : { orderBy?: debtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, debtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the debt model
   */
  readonly fields: debtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for debt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__debtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends debt$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, debt$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$debt_paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the debt model
   */
  interface debtFieldRefs {
    readonly id: FieldRef<"debt", 'String'>
    readonly userId: FieldRef<"debt", 'String'>
    readonly name: FieldRef<"debt", 'String'>
    readonly balance: FieldRef<"debt", 'Decimal'>
    readonly currentBalance: FieldRef<"debt", 'Decimal'>
    readonly interestRate: FieldRef<"debt", 'Decimal'>
    readonly minimumPayment: FieldRef<"debt", 'Decimal'>
    readonly dueDate: FieldRef<"debt", 'DateTime'>
    readonly extraPayment: FieldRef<"debt", 'Decimal'>
    readonly createdAt: FieldRef<"debt", 'DateTime'>
    readonly updatedAt: FieldRef<"debt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * debt findUnique
   */
  export type debtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * Filter, which debt to fetch.
     */
    where: debtWhereUniqueInput
  }

  /**
   * debt findUniqueOrThrow
   */
  export type debtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * Filter, which debt to fetch.
     */
    where: debtWhereUniqueInput
  }

  /**
   * debt findFirst
   */
  export type debtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * Filter, which debt to fetch.
     */
    where?: debtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debts to fetch.
     */
    orderBy?: debtOrderByWithRelationInput | debtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for debts.
     */
    cursor?: debtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * debt findFirstOrThrow
   */
  export type debtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * Filter, which debt to fetch.
     */
    where?: debtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debts to fetch.
     */
    orderBy?: debtOrderByWithRelationInput | debtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for debts.
     */
    cursor?: debtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * debt findMany
   */
  export type debtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * Filter, which debts to fetch.
     */
    where?: debtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debts to fetch.
     */
    orderBy?: debtOrderByWithRelationInput | debtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing debts.
     */
    cursor?: debtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debts.
     */
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * debt create
   */
  export type debtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * The data needed to create a debt.
     */
    data: XOR<debtCreateInput, debtUncheckedCreateInput>
  }

  /**
   * debt createMany
   */
  export type debtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many debts.
     */
    data: debtCreateManyInput | debtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * debt update
   */
  export type debtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * The data needed to update a debt.
     */
    data: XOR<debtUpdateInput, debtUncheckedUpdateInput>
    /**
     * Choose, which debt to update.
     */
    where: debtWhereUniqueInput
  }

  /**
   * debt updateMany
   */
  export type debtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update debts.
     */
    data: XOR<debtUpdateManyMutationInput, debtUncheckedUpdateManyInput>
    /**
     * Filter which debts to update
     */
    where?: debtWhereInput
    /**
     * Limit how many debts to update.
     */
    limit?: number
  }

  /**
   * debt upsert
   */
  export type debtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * The filter to search for the debt to update in case it exists.
     */
    where: debtWhereUniqueInput
    /**
     * In case the debt found by the `where` argument doesn't exist, create a new debt with this data.
     */
    create: XOR<debtCreateInput, debtUncheckedCreateInput>
    /**
     * In case the debt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<debtUpdateInput, debtUncheckedUpdateInput>
  }

  /**
   * debt delete
   */
  export type debtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
    /**
     * Filter which debt to delete.
     */
    where: debtWhereUniqueInput
  }

  /**
   * debt deleteMany
   */
  export type debtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which debts to delete
     */
    where?: debtWhereInput
    /**
     * Limit how many debts to delete.
     */
    limit?: number
  }

  /**
   * debt.payments
   */
  export type debt$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt_payment
     */
    select?: debt_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt_payment
     */
    omit?: debt_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debt_paymentInclude<ExtArgs> | null
    where?: debt_paymentWhereInput
    orderBy?: debt_paymentOrderByWithRelationInput | debt_paymentOrderByWithRelationInput[]
    cursor?: debt_paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Debt_paymentScalarFieldEnum | Debt_paymentScalarFieldEnum[]
  }

  /**
   * debt without action
   */
  export type debtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debt
     */
    select?: debtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the debt
     */
    omit?: debtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: debtInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Credit_cardsScalarFieldEnum: {
    CARD_ID: 'CARD_ID',
    USER_ID: 'USER_ID',
    CARD_NUMBER: 'CARD_NUMBER',
    CARD_TYPE: 'CARD_TYPE',
    CREDIT_LIMIT: 'CREDIT_LIMIT',
    BALANCE: 'BALANCE',
    INTEREST_RATE: 'INTEREST_RATE',
    DUE_DATE: 'DUE_DATE',
    STATUS: 'STATUS'
  };

  export type Credit_cardsScalarFieldEnum = (typeof Credit_cardsScalarFieldEnum)[keyof typeof Credit_cardsScalarFieldEnum]


  export const Payment_planScalarFieldEnum: {
    PLAN_ID: 'PLAN_ID',
    USER_ID: 'USER_ID',
    CARD_ID: 'CARD_ID',
    CHOSEN_PLAN: 'CHOSEN_PLAN',
    PROGRESS: 'PROGRESS',
    PLAN_START: 'PLAN_START',
    EST_PLAN_FINISH: 'EST_PLAN_FINISH'
  };

  export type Payment_planScalarFieldEnum = (typeof Payment_planScalarFieldEnum)[keyof typeof Payment_planScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    PAYMENT_ID: 'PAYMENT_ID',
    USER_ID: 'USER_ID',
    CARD_ID: 'CARD_ID',
    PAID: 'PAID',
    PAYMENT_DATE: 'PAYMENT_DATE',
    PAYMENT_METHOD: 'PAYMENT_METHOD',
    STATUS: 'STATUS'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const PlaidtransactionScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    name: 'name',
    amount: 'amount',
    date: 'date',
    account_id: 'account_id',
    userId: 'userId',
    category: 'category',
    iso_currency_code: 'iso_currency_code',
    createdAt: 'createdAt'
  };

  export type PlaidtransactionScalarFieldEnum = (typeof PlaidtransactionScalarFieldEnum)[keyof typeof PlaidtransactionScalarFieldEnum]


  export const Security_logScalarFieldEnum: {
    LOG_ID: 'LOG_ID',
    USER_ID: 'USER_ID',
    ACTION: 'ACTION',
    LOG_TIME: 'LOG_TIME'
  };

  export type Security_logScalarFieldEnum = (typeof Security_logScalarFieldEnum)[keyof typeof Security_logScalarFieldEnum]


  export const SettlementsScalarFieldEnum: {
    SET_ID: 'SET_ID',
    USER_ID: 'USER_ID',
    CARD_ID: 'CARD_ID',
    ORIGINAL_AMOUNT: 'ORIGINAL_AMOUNT',
    SETTLED_AMOUNT: 'SETTLED_AMOUNT',
    SET_DATE: 'SET_DATE',
    STATUS: 'STATUS'
  };

  export type SettlementsScalarFieldEnum = (typeof SettlementsScalarFieldEnum)[keyof typeof SettlementsScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    TRANS_ID: 'TRANS_ID',
    CARD_ID: 'CARD_ID',
    TRANS_TYPE: 'TRANS_TYPE',
    AMOUNT: 'AMOUNT',
    MERCHANT: 'MERCHANT',
    TRANS_DATE: 'TRANS_DATE'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const User_sessionScalarFieldEnum: {
    SESSION_ID: 'SESSION_ID',
    USER_ID: 'USER_ID',
    SESSION_TOKEN: 'SESSION_TOKEN',
    EXPIRES: 'EXPIRES'
  };

  export type User_sessionScalarFieldEnum = (typeof User_sessionScalarFieldEnum)[keyof typeof User_sessionScalarFieldEnum]


  export const UserplaiditemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemId: 'itemId',
    encryptedAccessToken: 'encryptedAccessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserplaiditemScalarFieldEnum = (typeof UserplaiditemScalarFieldEnum)[keyof typeof UserplaiditemScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    USER_ID: 'USER_ID',
    PASS: 'PASS',
    USER_LNAME: 'USER_LNAME',
    USER_FNAME: 'USER_FNAME',
    STREET: 'STREET',
    CITY: 'CITY',
    STATE: 'STATE',
    ZIP: 'ZIP',
    GENDER: 'GENDER',
    PHONE: 'PHONE',
    EMAIL: 'EMAIL'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Debt_paymentScalarFieldEnum: {
    id: 'id',
    debtId: 'debtId',
    userId: 'userId',
    amount: 'amount',
    date: 'date',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Debt_paymentScalarFieldEnum = (typeof Debt_paymentScalarFieldEnum)[keyof typeof Debt_paymentScalarFieldEnum]


  export const DebtScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    balance: 'balance',
    currentBalance: 'currentBalance',
    interestRate: 'interestRate',
    minimumPayment: 'minimumPayment',
    dueDate: 'dueDate',
    extraPayment: 'extraPayment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DebtScalarFieldEnum = (typeof DebtScalarFieldEnum)[keyof typeof DebtScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const credit_cardsOrderByRelevanceFieldEnum: {
    CARD_NUMBER: 'CARD_NUMBER'
  };

  export type credit_cardsOrderByRelevanceFieldEnum = (typeof credit_cardsOrderByRelevanceFieldEnum)[keyof typeof credit_cardsOrderByRelevanceFieldEnum]


  export const plaidtransactionOrderByRelevanceFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    name: 'name',
    account_id: 'account_id',
    userId: 'userId',
    category: 'category',
    iso_currency_code: 'iso_currency_code'
  };

  export type plaidtransactionOrderByRelevanceFieldEnum = (typeof plaidtransactionOrderByRelevanceFieldEnum)[keyof typeof plaidtransactionOrderByRelevanceFieldEnum]


  export const security_logOrderByRelevanceFieldEnum: {
    ACTION: 'ACTION'
  };

  export type security_logOrderByRelevanceFieldEnum = (typeof security_logOrderByRelevanceFieldEnum)[keyof typeof security_logOrderByRelevanceFieldEnum]


  export const transactionsOrderByRelevanceFieldEnum: {
    MERCHANT: 'MERCHANT'
  };

  export type transactionsOrderByRelevanceFieldEnum = (typeof transactionsOrderByRelevanceFieldEnum)[keyof typeof transactionsOrderByRelevanceFieldEnum]


  export const user_sessionOrderByRelevanceFieldEnum: {
    SESSION_TOKEN: 'SESSION_TOKEN'
  };

  export type user_sessionOrderByRelevanceFieldEnum = (typeof user_sessionOrderByRelevanceFieldEnum)[keyof typeof user_sessionOrderByRelevanceFieldEnum]


  export const userplaiditemOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemId: 'itemId',
    encryptedAccessToken: 'encryptedAccessToken'
  };

  export type userplaiditemOrderByRelevanceFieldEnum = (typeof userplaiditemOrderByRelevanceFieldEnum)[keyof typeof userplaiditemOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    PASS: 'PASS',
    USER_LNAME: 'USER_LNAME',
    USER_FNAME: 'USER_FNAME',
    STREET: 'STREET',
    CITY: 'CITY',
    STATE: 'STATE',
    ZIP: 'ZIP',
    GENDER: 'GENDER',
    PHONE: 'PHONE',
    EMAIL: 'EMAIL'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  export const debt_paymentOrderByRelevanceFieldEnum: {
    id: 'id',
    debtId: 'debtId',
    userId: 'userId',
    notes: 'notes'
  };

  export type debt_paymentOrderByRelevanceFieldEnum = (typeof debt_paymentOrderByRelevanceFieldEnum)[keyof typeof debt_paymentOrderByRelevanceFieldEnum]


  export const debtOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name'
  };

  export type debtOrderByRelevanceFieldEnum = (typeof debtOrderByRelevanceFieldEnum)[keyof typeof debtOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'credit_cards_CARD_TYPE'
   */
  export type Enumcredit_cards_CARD_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'credit_cards_CARD_TYPE'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'credit_cards_STATUS'
   */
  export type Enumcredit_cards_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'credit_cards_STATUS'>
    


  /**
   * Reference to a field of type 'payment_plan_CHOSEN_PLAN'
   */
  export type Enumpayment_plan_CHOSEN_PLANFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_plan_CHOSEN_PLAN'>
    


  /**
   * Reference to a field of type 'payments_PAYMENT_METHOD'
   */
  export type Enumpayments_PAYMENT_METHODFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payments_PAYMENT_METHOD'>
    


  /**
   * Reference to a field of type 'payments_STATUS'
   */
  export type Enumpayments_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payments_STATUS'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'settlements_STATUS'
   */
  export type Enumsettlements_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'settlements_STATUS'>
    


  /**
   * Reference to a field of type 'transactions_TRANS_TYPE'
   */
  export type Enumtransactions_TRANS_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'transactions_TRANS_TYPE'>
    
  /**
   * Deep Input Types
   */


  export type credit_cardsWhereInput = {
    AND?: credit_cardsWhereInput | credit_cardsWhereInput[]
    OR?: credit_cardsWhereInput[]
    NOT?: credit_cardsWhereInput | credit_cardsWhereInput[]
    CARD_ID?: IntFilter<"credit_cards"> | number
    USER_ID?: IntFilter<"credit_cards"> | number
    CARD_NUMBER?: StringFilter<"credit_cards"> | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFilter<"credit_cards"> | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string
    BALANCE?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFilter<"credit_cards"> | Date | string
    STATUS?: Enumcredit_cards_STATUSNullableFilter<"credit_cards"> | $Enums.credit_cards_STATUS | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    payment_plan?: Payment_planListRelationFilter
    payments?: PaymentsListRelationFilter
    settlements?: SettlementsListRelationFilter
    transactions?: TransactionsListRelationFilter
  }

  export type credit_cardsOrderByWithRelationInput = {
    CARD_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_NUMBER?: SortOrder
    CARD_TYPE?: SortOrder
    CREDIT_LIMIT?: SortOrder
    BALANCE?: SortOrderInput | SortOrder
    INTEREST_RATE?: SortOrderInput | SortOrder
    DUE_DATE?: SortOrder
    STATUS?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    payment_plan?: payment_planOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    settlements?: settlementsOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
    _relevance?: credit_cardsOrderByRelevanceInput
  }

  export type credit_cardsWhereUniqueInput = Prisma.AtLeast<{
    CARD_ID?: number
    CARD_NUMBER?: string
    AND?: credit_cardsWhereInput | credit_cardsWhereInput[]
    OR?: credit_cardsWhereInput[]
    NOT?: credit_cardsWhereInput | credit_cardsWhereInput[]
    USER_ID?: IntFilter<"credit_cards"> | number
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFilter<"credit_cards"> | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string
    BALANCE?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFilter<"credit_cards"> | Date | string
    STATUS?: Enumcredit_cards_STATUSNullableFilter<"credit_cards"> | $Enums.credit_cards_STATUS | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    payment_plan?: Payment_planListRelationFilter
    payments?: PaymentsListRelationFilter
    settlements?: SettlementsListRelationFilter
    transactions?: TransactionsListRelationFilter
  }, "CARD_ID" | "CARD_NUMBER">

  export type credit_cardsOrderByWithAggregationInput = {
    CARD_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_NUMBER?: SortOrder
    CARD_TYPE?: SortOrder
    CREDIT_LIMIT?: SortOrder
    BALANCE?: SortOrderInput | SortOrder
    INTEREST_RATE?: SortOrderInput | SortOrder
    DUE_DATE?: SortOrder
    STATUS?: SortOrderInput | SortOrder
    _count?: credit_cardsCountOrderByAggregateInput
    _avg?: credit_cardsAvgOrderByAggregateInput
    _max?: credit_cardsMaxOrderByAggregateInput
    _min?: credit_cardsMinOrderByAggregateInput
    _sum?: credit_cardsSumOrderByAggregateInput
  }

  export type credit_cardsScalarWhereWithAggregatesInput = {
    AND?: credit_cardsScalarWhereWithAggregatesInput | credit_cardsScalarWhereWithAggregatesInput[]
    OR?: credit_cardsScalarWhereWithAggregatesInput[]
    NOT?: credit_cardsScalarWhereWithAggregatesInput | credit_cardsScalarWhereWithAggregatesInput[]
    CARD_ID?: IntWithAggregatesFilter<"credit_cards"> | number
    USER_ID?: IntWithAggregatesFilter<"credit_cards"> | number
    CARD_NUMBER?: StringWithAggregatesFilter<"credit_cards"> | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEWithAggregatesFilter<"credit_cards"> | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalWithAggregatesFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string
    BALANCE?: DecimalNullableWithAggregatesFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: DecimalNullableWithAggregatesFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeWithAggregatesFilter<"credit_cards"> | Date | string
    STATUS?: Enumcredit_cards_STATUSNullableWithAggregatesFilter<"credit_cards"> | $Enums.credit_cards_STATUS | null
  }

  export type payment_planWhereInput = {
    AND?: payment_planWhereInput | payment_planWhereInput[]
    OR?: payment_planWhereInput[]
    NOT?: payment_planWhereInput | payment_planWhereInput[]
    PLAN_ID?: IntFilter<"payment_plan"> | number
    USER_ID?: IntFilter<"payment_plan"> | number
    CARD_ID?: IntFilter<"payment_plan"> | number
    CHOSEN_PLAN?: Enumpayment_plan_CHOSEN_PLANNullableFilter<"payment_plan"> | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFilter<"payment_plan"> | number
    PLAN_START?: DateTimeNullableFilter<"payment_plan"> | Date | string | null
    EST_PLAN_FINISH?: DateTimeNullableFilter<"payment_plan"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    credit_cards?: XOR<Credit_cardsScalarRelationFilter, credit_cardsWhereInput>
  }

  export type payment_planOrderByWithRelationInput = {
    PLAN_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    CHOSEN_PLAN?: SortOrderInput | SortOrder
    PROGRESS?: SortOrder
    PLAN_START?: SortOrderInput | SortOrder
    EST_PLAN_FINISH?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    credit_cards?: credit_cardsOrderByWithRelationInput
  }

  export type payment_planWhereUniqueInput = Prisma.AtLeast<{
    PLAN_ID?: number
    AND?: payment_planWhereInput | payment_planWhereInput[]
    OR?: payment_planWhereInput[]
    NOT?: payment_planWhereInput | payment_planWhereInput[]
    USER_ID?: IntFilter<"payment_plan"> | number
    CARD_ID?: IntFilter<"payment_plan"> | number
    CHOSEN_PLAN?: Enumpayment_plan_CHOSEN_PLANNullableFilter<"payment_plan"> | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFilter<"payment_plan"> | number
    PLAN_START?: DateTimeNullableFilter<"payment_plan"> | Date | string | null
    EST_PLAN_FINISH?: DateTimeNullableFilter<"payment_plan"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    credit_cards?: XOR<Credit_cardsScalarRelationFilter, credit_cardsWhereInput>
  }, "PLAN_ID">

  export type payment_planOrderByWithAggregationInput = {
    PLAN_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    CHOSEN_PLAN?: SortOrderInput | SortOrder
    PROGRESS?: SortOrder
    PLAN_START?: SortOrderInput | SortOrder
    EST_PLAN_FINISH?: SortOrderInput | SortOrder
    _count?: payment_planCountOrderByAggregateInput
    _avg?: payment_planAvgOrderByAggregateInput
    _max?: payment_planMaxOrderByAggregateInput
    _min?: payment_planMinOrderByAggregateInput
    _sum?: payment_planSumOrderByAggregateInput
  }

  export type payment_planScalarWhereWithAggregatesInput = {
    AND?: payment_planScalarWhereWithAggregatesInput | payment_planScalarWhereWithAggregatesInput[]
    OR?: payment_planScalarWhereWithAggregatesInput[]
    NOT?: payment_planScalarWhereWithAggregatesInput | payment_planScalarWhereWithAggregatesInput[]
    PLAN_ID?: IntWithAggregatesFilter<"payment_plan"> | number
    USER_ID?: IntWithAggregatesFilter<"payment_plan"> | number
    CARD_ID?: IntWithAggregatesFilter<"payment_plan"> | number
    CHOSEN_PLAN?: Enumpayment_plan_CHOSEN_PLANNullableWithAggregatesFilter<"payment_plan"> | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntWithAggregatesFilter<"payment_plan"> | number
    PLAN_START?: DateTimeNullableWithAggregatesFilter<"payment_plan"> | Date | string | null
    EST_PLAN_FINISH?: DateTimeNullableWithAggregatesFilter<"payment_plan"> | Date | string | null
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    PAYMENT_ID?: IntFilter<"payments"> | number
    USER_ID?: IntNullableFilter<"payments"> | number | null
    CARD_ID?: IntNullableFilter<"payments"> | number | null
    PAID?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: DateTimeNullableFilter<"payments"> | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFilter<"payments"> | $Enums.payments_PAYMENT_METHOD
    STATUS?: Enumpayments_STATUSNullableFilter<"payments"> | $Enums.payments_STATUS | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    credit_cards?: XOR<Credit_cardsNullableScalarRelationFilter, credit_cardsWhereInput> | null
  }

  export type paymentsOrderByWithRelationInput = {
    PAYMENT_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    CARD_ID?: SortOrderInput | SortOrder
    PAID?: SortOrder
    PAYMENT_DATE?: SortOrderInput | SortOrder
    PAYMENT_METHOD?: SortOrder
    STATUS?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    credit_cards?: credit_cardsOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    PAYMENT_ID?: number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    USER_ID?: IntNullableFilter<"payments"> | number | null
    CARD_ID?: IntNullableFilter<"payments"> | number | null
    PAID?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: DateTimeNullableFilter<"payments"> | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFilter<"payments"> | $Enums.payments_PAYMENT_METHOD
    STATUS?: Enumpayments_STATUSNullableFilter<"payments"> | $Enums.payments_STATUS | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    credit_cards?: XOR<Credit_cardsNullableScalarRelationFilter, credit_cardsWhereInput> | null
  }, "PAYMENT_ID">

  export type paymentsOrderByWithAggregationInput = {
    PAYMENT_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    CARD_ID?: SortOrderInput | SortOrder
    PAID?: SortOrder
    PAYMENT_DATE?: SortOrderInput | SortOrder
    PAYMENT_METHOD?: SortOrder
    STATUS?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    PAYMENT_ID?: IntWithAggregatesFilter<"payments"> | number
    USER_ID?: IntNullableWithAggregatesFilter<"payments"> | number | null
    CARD_ID?: IntNullableWithAggregatesFilter<"payments"> | number | null
    PAID?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODWithAggregatesFilter<"payments"> | $Enums.payments_PAYMENT_METHOD
    STATUS?: Enumpayments_STATUSNullableWithAggregatesFilter<"payments"> | $Enums.payments_STATUS | null
  }

  export type plaidtransactionWhereInput = {
    AND?: plaidtransactionWhereInput | plaidtransactionWhereInput[]
    OR?: plaidtransactionWhereInput[]
    NOT?: plaidtransactionWhereInput | plaidtransactionWhereInput[]
    id?: StringFilter<"plaidtransaction"> | string
    transactionId?: StringNullableFilter<"plaidtransaction"> | string | null
    name?: StringFilter<"plaidtransaction"> | string
    amount?: FloatFilter<"plaidtransaction"> | number
    date?: DateTimeFilter<"plaidtransaction"> | Date | string
    account_id?: StringFilter<"plaidtransaction"> | string
    userId?: StringFilter<"plaidtransaction"> | string
    category?: StringNullableFilter<"plaidtransaction"> | string | null
    iso_currency_code?: StringNullableFilter<"plaidtransaction"> | string | null
    createdAt?: DateTimeNullableFilter<"plaidtransaction"> | Date | string | null
  }

  export type plaidtransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    name?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    account_id?: SortOrder
    userId?: SortOrder
    category?: SortOrderInput | SortOrder
    iso_currency_code?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _relevance?: plaidtransactionOrderByRelevanceInput
  }

  export type plaidtransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: plaidtransactionWhereInput | plaidtransactionWhereInput[]
    OR?: plaidtransactionWhereInput[]
    NOT?: plaidtransactionWhereInput | plaidtransactionWhereInput[]
    name?: StringFilter<"plaidtransaction"> | string
    amount?: FloatFilter<"plaidtransaction"> | number
    date?: DateTimeFilter<"plaidtransaction"> | Date | string
    account_id?: StringFilter<"plaidtransaction"> | string
    userId?: StringFilter<"plaidtransaction"> | string
    category?: StringNullableFilter<"plaidtransaction"> | string | null
    iso_currency_code?: StringNullableFilter<"plaidtransaction"> | string | null
    createdAt?: DateTimeNullableFilter<"plaidtransaction"> | Date | string | null
  }, "id" | "transactionId">

  export type plaidtransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    name?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    account_id?: SortOrder
    userId?: SortOrder
    category?: SortOrderInput | SortOrder
    iso_currency_code?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: plaidtransactionCountOrderByAggregateInput
    _avg?: plaidtransactionAvgOrderByAggregateInput
    _max?: plaidtransactionMaxOrderByAggregateInput
    _min?: plaidtransactionMinOrderByAggregateInput
    _sum?: plaidtransactionSumOrderByAggregateInput
  }

  export type plaidtransactionScalarWhereWithAggregatesInput = {
    AND?: plaidtransactionScalarWhereWithAggregatesInput | plaidtransactionScalarWhereWithAggregatesInput[]
    OR?: plaidtransactionScalarWhereWithAggregatesInput[]
    NOT?: plaidtransactionScalarWhereWithAggregatesInput | plaidtransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"plaidtransaction"> | string
    transactionId?: StringNullableWithAggregatesFilter<"plaidtransaction"> | string | null
    name?: StringWithAggregatesFilter<"plaidtransaction"> | string
    amount?: FloatWithAggregatesFilter<"plaidtransaction"> | number
    date?: DateTimeWithAggregatesFilter<"plaidtransaction"> | Date | string
    account_id?: StringWithAggregatesFilter<"plaidtransaction"> | string
    userId?: StringWithAggregatesFilter<"plaidtransaction"> | string
    category?: StringNullableWithAggregatesFilter<"plaidtransaction"> | string | null
    iso_currency_code?: StringNullableWithAggregatesFilter<"plaidtransaction"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"plaidtransaction"> | Date | string | null
  }

  export type security_logWhereInput = {
    AND?: security_logWhereInput | security_logWhereInput[]
    OR?: security_logWhereInput[]
    NOT?: security_logWhereInput | security_logWhereInput[]
    LOG_ID?: IntFilter<"security_log"> | number
    USER_ID?: IntNullableFilter<"security_log"> | number | null
    ACTION?: StringFilter<"security_log"> | string
    LOG_TIME?: DateTimeNullableFilter<"security_log"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type security_logOrderByWithRelationInput = {
    LOG_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    ACTION?: SortOrder
    LOG_TIME?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: security_logOrderByRelevanceInput
  }

  export type security_logWhereUniqueInput = Prisma.AtLeast<{
    LOG_ID?: number
    AND?: security_logWhereInput | security_logWhereInput[]
    OR?: security_logWhereInput[]
    NOT?: security_logWhereInput | security_logWhereInput[]
    USER_ID?: IntNullableFilter<"security_log"> | number | null
    ACTION?: StringFilter<"security_log"> | string
    LOG_TIME?: DateTimeNullableFilter<"security_log"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "LOG_ID">

  export type security_logOrderByWithAggregationInput = {
    LOG_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    ACTION?: SortOrder
    LOG_TIME?: SortOrderInput | SortOrder
    _count?: security_logCountOrderByAggregateInput
    _avg?: security_logAvgOrderByAggregateInput
    _max?: security_logMaxOrderByAggregateInput
    _min?: security_logMinOrderByAggregateInput
    _sum?: security_logSumOrderByAggregateInput
  }

  export type security_logScalarWhereWithAggregatesInput = {
    AND?: security_logScalarWhereWithAggregatesInput | security_logScalarWhereWithAggregatesInput[]
    OR?: security_logScalarWhereWithAggregatesInput[]
    NOT?: security_logScalarWhereWithAggregatesInput | security_logScalarWhereWithAggregatesInput[]
    LOG_ID?: IntWithAggregatesFilter<"security_log"> | number
    USER_ID?: IntNullableWithAggregatesFilter<"security_log"> | number | null
    ACTION?: StringWithAggregatesFilter<"security_log"> | string
    LOG_TIME?: DateTimeNullableWithAggregatesFilter<"security_log"> | Date | string | null
  }

  export type settlementsWhereInput = {
    AND?: settlementsWhereInput | settlementsWhereInput[]
    OR?: settlementsWhereInput[]
    NOT?: settlementsWhereInput | settlementsWhereInput[]
    SET_ID?: IntFilter<"settlements"> | number
    USER_ID?: IntNullableFilter<"settlements"> | number | null
    CARD_ID?: IntNullableFilter<"settlements"> | number | null
    ORIGINAL_AMOUNT?: DecimalFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SET_DATE?: DateTimeNullableFilter<"settlements"> | Date | string | null
    STATUS?: Enumsettlements_STATUSNullableFilter<"settlements"> | $Enums.settlements_STATUS | null
    credit_cards?: XOR<Credit_cardsNullableScalarRelationFilter, credit_cardsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type settlementsOrderByWithRelationInput = {
    SET_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    CARD_ID?: SortOrderInput | SortOrder
    ORIGINAL_AMOUNT?: SortOrder
    SETTLED_AMOUNT?: SortOrder
    SET_DATE?: SortOrderInput | SortOrder
    STATUS?: SortOrderInput | SortOrder
    credit_cards?: credit_cardsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type settlementsWhereUniqueInput = Prisma.AtLeast<{
    SET_ID?: number
    AND?: settlementsWhereInput | settlementsWhereInput[]
    OR?: settlementsWhereInput[]
    NOT?: settlementsWhereInput | settlementsWhereInput[]
    USER_ID?: IntNullableFilter<"settlements"> | number | null
    CARD_ID?: IntNullableFilter<"settlements"> | number | null
    ORIGINAL_AMOUNT?: DecimalFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SET_DATE?: DateTimeNullableFilter<"settlements"> | Date | string | null
    STATUS?: Enumsettlements_STATUSNullableFilter<"settlements"> | $Enums.settlements_STATUS | null
    credit_cards?: XOR<Credit_cardsNullableScalarRelationFilter, credit_cardsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "SET_ID">

  export type settlementsOrderByWithAggregationInput = {
    SET_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    CARD_ID?: SortOrderInput | SortOrder
    ORIGINAL_AMOUNT?: SortOrder
    SETTLED_AMOUNT?: SortOrder
    SET_DATE?: SortOrderInput | SortOrder
    STATUS?: SortOrderInput | SortOrder
    _count?: settlementsCountOrderByAggregateInput
    _avg?: settlementsAvgOrderByAggregateInput
    _max?: settlementsMaxOrderByAggregateInput
    _min?: settlementsMinOrderByAggregateInput
    _sum?: settlementsSumOrderByAggregateInput
  }

  export type settlementsScalarWhereWithAggregatesInput = {
    AND?: settlementsScalarWhereWithAggregatesInput | settlementsScalarWhereWithAggregatesInput[]
    OR?: settlementsScalarWhereWithAggregatesInput[]
    NOT?: settlementsScalarWhereWithAggregatesInput | settlementsScalarWhereWithAggregatesInput[]
    SET_ID?: IntWithAggregatesFilter<"settlements"> | number
    USER_ID?: IntNullableWithAggregatesFilter<"settlements"> | number | null
    CARD_ID?: IntNullableWithAggregatesFilter<"settlements"> | number | null
    ORIGINAL_AMOUNT?: DecimalWithAggregatesFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalWithAggregatesFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SET_DATE?: DateTimeNullableWithAggregatesFilter<"settlements"> | Date | string | null
    STATUS?: Enumsettlements_STATUSNullableWithAggregatesFilter<"settlements"> | $Enums.settlements_STATUS | null
  }

  export type transactionsWhereInput = {
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    TRANS_ID?: IntFilter<"transactions"> | number
    CARD_ID?: IntNullableFilter<"transactions"> | number | null
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFilter<"transactions"> | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    MERCHANT?: StringNullableFilter<"transactions"> | string | null
    TRANS_DATE?: DateTimeNullableFilter<"transactions"> | Date | string | null
    credit_cards?: XOR<Credit_cardsNullableScalarRelationFilter, credit_cardsWhereInput> | null
  }

  export type transactionsOrderByWithRelationInput = {
    TRANS_ID?: SortOrder
    CARD_ID?: SortOrderInput | SortOrder
    TRANS_TYPE?: SortOrder
    AMOUNT?: SortOrder
    MERCHANT?: SortOrderInput | SortOrder
    TRANS_DATE?: SortOrderInput | SortOrder
    credit_cards?: credit_cardsOrderByWithRelationInput
    _relevance?: transactionsOrderByRelevanceInput
  }

  export type transactionsWhereUniqueInput = Prisma.AtLeast<{
    TRANS_ID?: number
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    CARD_ID?: IntNullableFilter<"transactions"> | number | null
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFilter<"transactions"> | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    MERCHANT?: StringNullableFilter<"transactions"> | string | null
    TRANS_DATE?: DateTimeNullableFilter<"transactions"> | Date | string | null
    credit_cards?: XOR<Credit_cardsNullableScalarRelationFilter, credit_cardsWhereInput> | null
  }, "TRANS_ID">

  export type transactionsOrderByWithAggregationInput = {
    TRANS_ID?: SortOrder
    CARD_ID?: SortOrderInput | SortOrder
    TRANS_TYPE?: SortOrder
    AMOUNT?: SortOrder
    MERCHANT?: SortOrderInput | SortOrder
    TRANS_DATE?: SortOrderInput | SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _avg?: transactionsAvgOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
    _sum?: transactionsSumOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    OR?: transactionsScalarWhereWithAggregatesInput[]
    NOT?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    TRANS_ID?: IntWithAggregatesFilter<"transactions"> | number
    CARD_ID?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEWithAggregatesFilter<"transactions"> | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalWithAggregatesFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    MERCHANT?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    TRANS_DATE?: DateTimeNullableWithAggregatesFilter<"transactions"> | Date | string | null
  }

  export type user_sessionWhereInput = {
    AND?: user_sessionWhereInput | user_sessionWhereInput[]
    OR?: user_sessionWhereInput[]
    NOT?: user_sessionWhereInput | user_sessionWhereInput[]
    SESSION_ID?: IntFilter<"user_session"> | number
    USER_ID?: IntNullableFilter<"user_session"> | number | null
    SESSION_TOKEN?: StringFilter<"user_session"> | string
    EXPIRES?: DateTimeFilter<"user_session"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type user_sessionOrderByWithRelationInput = {
    SESSION_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    SESSION_TOKEN?: SortOrder
    EXPIRES?: SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: user_sessionOrderByRelevanceInput
  }

  export type user_sessionWhereUniqueInput = Prisma.AtLeast<{
    SESSION_ID?: number
    SESSION_TOKEN?: string
    AND?: user_sessionWhereInput | user_sessionWhereInput[]
    OR?: user_sessionWhereInput[]
    NOT?: user_sessionWhereInput | user_sessionWhereInput[]
    USER_ID?: IntNullableFilter<"user_session"> | number | null
    EXPIRES?: DateTimeFilter<"user_session"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "SESSION_ID" | "SESSION_TOKEN">

  export type user_sessionOrderByWithAggregationInput = {
    SESSION_ID?: SortOrder
    USER_ID?: SortOrderInput | SortOrder
    SESSION_TOKEN?: SortOrder
    EXPIRES?: SortOrder
    _count?: user_sessionCountOrderByAggregateInput
    _avg?: user_sessionAvgOrderByAggregateInput
    _max?: user_sessionMaxOrderByAggregateInput
    _min?: user_sessionMinOrderByAggregateInput
    _sum?: user_sessionSumOrderByAggregateInput
  }

  export type user_sessionScalarWhereWithAggregatesInput = {
    AND?: user_sessionScalarWhereWithAggregatesInput | user_sessionScalarWhereWithAggregatesInput[]
    OR?: user_sessionScalarWhereWithAggregatesInput[]
    NOT?: user_sessionScalarWhereWithAggregatesInput | user_sessionScalarWhereWithAggregatesInput[]
    SESSION_ID?: IntWithAggregatesFilter<"user_session"> | number
    USER_ID?: IntNullableWithAggregatesFilter<"user_session"> | number | null
    SESSION_TOKEN?: StringWithAggregatesFilter<"user_session"> | string
    EXPIRES?: DateTimeWithAggregatesFilter<"user_session"> | Date | string
  }

  export type userplaiditemWhereInput = {
    AND?: userplaiditemWhereInput | userplaiditemWhereInput[]
    OR?: userplaiditemWhereInput[]
    NOT?: userplaiditemWhereInput | userplaiditemWhereInput[]
    id?: StringFilter<"userplaiditem"> | string
    userId?: StringFilter<"userplaiditem"> | string
    itemId?: StringFilter<"userplaiditem"> | string
    encryptedAccessToken?: StringFilter<"userplaiditem"> | string
    createdAt?: DateTimeNullableFilter<"userplaiditem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"userplaiditem"> | Date | string | null
  }

  export type userplaiditemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    encryptedAccessToken?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: userplaiditemOrderByRelevanceInput
  }

  export type userplaiditemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    itemId?: string
    AND?: userplaiditemWhereInput | userplaiditemWhereInput[]
    OR?: userplaiditemWhereInput[]
    NOT?: userplaiditemWhereInput | userplaiditemWhereInput[]
    encryptedAccessToken?: StringFilter<"userplaiditem"> | string
    createdAt?: DateTimeNullableFilter<"userplaiditem"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"userplaiditem"> | Date | string | null
  }, "id" | "userId" | "itemId">

  export type userplaiditemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    encryptedAccessToken?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: userplaiditemCountOrderByAggregateInput
    _max?: userplaiditemMaxOrderByAggregateInput
    _min?: userplaiditemMinOrderByAggregateInput
  }

  export type userplaiditemScalarWhereWithAggregatesInput = {
    AND?: userplaiditemScalarWhereWithAggregatesInput | userplaiditemScalarWhereWithAggregatesInput[]
    OR?: userplaiditemScalarWhereWithAggregatesInput[]
    NOT?: userplaiditemScalarWhereWithAggregatesInput | userplaiditemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userplaiditem"> | string
    userId?: StringWithAggregatesFilter<"userplaiditem"> | string
    itemId?: StringWithAggregatesFilter<"userplaiditem"> | string
    encryptedAccessToken?: StringWithAggregatesFilter<"userplaiditem"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"userplaiditem"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"userplaiditem"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    USER_ID?: IntFilter<"users"> | number
    PASS?: StringFilter<"users"> | string
    USER_LNAME?: StringFilter<"users"> | string
    USER_FNAME?: StringFilter<"users"> | string
    STREET?: StringNullableFilter<"users"> | string | null
    CITY?: StringNullableFilter<"users"> | string | null
    STATE?: StringNullableFilter<"users"> | string | null
    ZIP?: StringNullableFilter<"users"> | string | null
    GENDER?: StringNullableFilter<"users"> | string | null
    PHONE?: StringNullableFilter<"users"> | string | null
    EMAIL?: StringNullableFilter<"users"> | string | null
    credit_cards?: Credit_cardsListRelationFilter
    payment_plan?: Payment_planListRelationFilter
    payments?: PaymentsListRelationFilter
    security_log?: Security_logListRelationFilter
    settlements?: SettlementsListRelationFilter
    user_session?: User_sessionListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    USER_ID?: SortOrder
    PASS?: SortOrder
    USER_LNAME?: SortOrder
    USER_FNAME?: SortOrder
    STREET?: SortOrderInput | SortOrder
    CITY?: SortOrderInput | SortOrder
    STATE?: SortOrderInput | SortOrder
    ZIP?: SortOrderInput | SortOrder
    GENDER?: SortOrderInput | SortOrder
    PHONE?: SortOrderInput | SortOrder
    EMAIL?: SortOrderInput | SortOrder
    credit_cards?: credit_cardsOrderByRelationAggregateInput
    payment_plan?: payment_planOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    security_log?: security_logOrderByRelationAggregateInput
    settlements?: settlementsOrderByRelationAggregateInput
    user_session?: user_sessionOrderByRelationAggregateInput
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    USER_ID?: number
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    PASS?: StringFilter<"users"> | string
    USER_LNAME?: StringFilter<"users"> | string
    USER_FNAME?: StringFilter<"users"> | string
    STREET?: StringNullableFilter<"users"> | string | null
    CITY?: StringNullableFilter<"users"> | string | null
    STATE?: StringNullableFilter<"users"> | string | null
    ZIP?: StringNullableFilter<"users"> | string | null
    GENDER?: StringNullableFilter<"users"> | string | null
    PHONE?: StringNullableFilter<"users"> | string | null
    EMAIL?: StringNullableFilter<"users"> | string | null
    credit_cards?: Credit_cardsListRelationFilter
    payment_plan?: Payment_planListRelationFilter
    payments?: PaymentsListRelationFilter
    security_log?: Security_logListRelationFilter
    settlements?: SettlementsListRelationFilter
    user_session?: User_sessionListRelationFilter
  }, "USER_ID">

  export type usersOrderByWithAggregationInput = {
    USER_ID?: SortOrder
    PASS?: SortOrder
    USER_LNAME?: SortOrder
    USER_FNAME?: SortOrder
    STREET?: SortOrderInput | SortOrder
    CITY?: SortOrderInput | SortOrder
    STATE?: SortOrderInput | SortOrder
    ZIP?: SortOrderInput | SortOrder
    GENDER?: SortOrderInput | SortOrder
    PHONE?: SortOrderInput | SortOrder
    EMAIL?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    USER_ID?: IntWithAggregatesFilter<"users"> | number
    PASS?: StringWithAggregatesFilter<"users"> | string
    USER_LNAME?: StringWithAggregatesFilter<"users"> | string
    USER_FNAME?: StringWithAggregatesFilter<"users"> | string
    STREET?: StringNullableWithAggregatesFilter<"users"> | string | null
    CITY?: StringNullableWithAggregatesFilter<"users"> | string | null
    STATE?: StringNullableWithAggregatesFilter<"users"> | string | null
    ZIP?: StringNullableWithAggregatesFilter<"users"> | string | null
    GENDER?: StringNullableWithAggregatesFilter<"users"> | string | null
    PHONE?: StringNullableWithAggregatesFilter<"users"> | string | null
    EMAIL?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type debt_paymentWhereInput = {
    AND?: debt_paymentWhereInput | debt_paymentWhereInput[]
    OR?: debt_paymentWhereInput[]
    NOT?: debt_paymentWhereInput | debt_paymentWhereInput[]
    id?: StringFilter<"debt_payment"> | string
    debtId?: StringFilter<"debt_payment"> | string
    userId?: StringFilter<"debt_payment"> | string
    amount?: DecimalFilter<"debt_payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"debt_payment"> | Date | string
    notes?: StringNullableFilter<"debt_payment"> | string | null
    createdAt?: DateTimeFilter<"debt_payment"> | Date | string
    updatedAt?: DateTimeFilter<"debt_payment"> | Date | string
    debt?: XOR<DebtScalarRelationFilter, debtWhereInput>
  }

  export type debt_paymentOrderByWithRelationInput = {
    id?: SortOrder
    debtId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debt?: debtOrderByWithRelationInput
    _relevance?: debt_paymentOrderByRelevanceInput
  }

  export type debt_paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: debt_paymentWhereInput | debt_paymentWhereInput[]
    OR?: debt_paymentWhereInput[]
    NOT?: debt_paymentWhereInput | debt_paymentWhereInput[]
    debtId?: StringFilter<"debt_payment"> | string
    userId?: StringFilter<"debt_payment"> | string
    amount?: DecimalFilter<"debt_payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"debt_payment"> | Date | string
    notes?: StringNullableFilter<"debt_payment"> | string | null
    createdAt?: DateTimeFilter<"debt_payment"> | Date | string
    updatedAt?: DateTimeFilter<"debt_payment"> | Date | string
    debt?: XOR<DebtScalarRelationFilter, debtWhereInput>
  }, "id">

  export type debt_paymentOrderByWithAggregationInput = {
    id?: SortOrder
    debtId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: debt_paymentCountOrderByAggregateInput
    _avg?: debt_paymentAvgOrderByAggregateInput
    _max?: debt_paymentMaxOrderByAggregateInput
    _min?: debt_paymentMinOrderByAggregateInput
    _sum?: debt_paymentSumOrderByAggregateInput
  }

  export type debt_paymentScalarWhereWithAggregatesInput = {
    AND?: debt_paymentScalarWhereWithAggregatesInput | debt_paymentScalarWhereWithAggregatesInput[]
    OR?: debt_paymentScalarWhereWithAggregatesInput[]
    NOT?: debt_paymentScalarWhereWithAggregatesInput | debt_paymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"debt_payment"> | string
    debtId?: StringWithAggregatesFilter<"debt_payment"> | string
    userId?: StringWithAggregatesFilter<"debt_payment"> | string
    amount?: DecimalWithAggregatesFilter<"debt_payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"debt_payment"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"debt_payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"debt_payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"debt_payment"> | Date | string
  }

  export type debtWhereInput = {
    AND?: debtWhereInput | debtWhereInput[]
    OR?: debtWhereInput[]
    NOT?: debtWhereInput | debtWhereInput[]
    id?: StringFilter<"debt"> | string
    userId?: StringFilter<"debt"> | string
    name?: StringFilter<"debt"> | string
    balance?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"debt"> | Date | string
    extraPayment?: DecimalNullableFilter<"debt"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"debt"> | Date | string
    updatedAt?: DateTimeFilter<"debt"> | Date | string
    payments?: Debt_paymentListRelationFilter
  }

  export type debtOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    currentBalance?: SortOrder
    interestRate?: SortOrder
    minimumPayment?: SortOrder
    dueDate?: SortOrder
    extraPayment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payments?: debt_paymentOrderByRelationAggregateInput
    _relevance?: debtOrderByRelevanceInput
  }

  export type debtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: debtWhereInput | debtWhereInput[]
    OR?: debtWhereInput[]
    NOT?: debtWhereInput | debtWhereInput[]
    userId?: StringFilter<"debt"> | string
    name?: StringFilter<"debt"> | string
    balance?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFilter<"debt"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"debt"> | Date | string
    extraPayment?: DecimalNullableFilter<"debt"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"debt"> | Date | string
    updatedAt?: DateTimeFilter<"debt"> | Date | string
    payments?: Debt_paymentListRelationFilter
  }, "id">

  export type debtOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    currentBalance?: SortOrder
    interestRate?: SortOrder
    minimumPayment?: SortOrder
    dueDate?: SortOrder
    extraPayment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: debtCountOrderByAggregateInput
    _avg?: debtAvgOrderByAggregateInput
    _max?: debtMaxOrderByAggregateInput
    _min?: debtMinOrderByAggregateInput
    _sum?: debtSumOrderByAggregateInput
  }

  export type debtScalarWhereWithAggregatesInput = {
    AND?: debtScalarWhereWithAggregatesInput | debtScalarWhereWithAggregatesInput[]
    OR?: debtScalarWhereWithAggregatesInput[]
    NOT?: debtScalarWhereWithAggregatesInput | debtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"debt"> | string
    userId?: StringWithAggregatesFilter<"debt"> | string
    name?: StringWithAggregatesFilter<"debt"> | string
    balance?: DecimalWithAggregatesFilter<"debt"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalWithAggregatesFilter<"debt"> | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalWithAggregatesFilter<"debt"> | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalWithAggregatesFilter<"debt"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeWithAggregatesFilter<"debt"> | Date | string
    extraPayment?: DecimalNullableWithAggregatesFilter<"debt"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"debt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"debt"> | Date | string
  }

  export type credit_cardsCreateInput = {
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    users: usersCreateNestedOneWithoutCredit_cardsInput
    payment_plan?: payment_planCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsUncheckedCreateInput = {
    CARD_ID?: number
    USER_ID: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsUpdateInput = {
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    users?: usersUpdateOneRequiredWithoutCredit_cardsNestedInput
    payment_plan?: payment_planUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsUncheckedUpdateInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsCreateManyInput = {
    CARD_ID?: number
    USER_ID: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
  }

  export type credit_cardsUpdateManyMutationInput = {
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
  }

  export type credit_cardsUncheckedUpdateManyInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
  }

  export type payment_planCreateInput = {
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
    users: usersCreateNestedOneWithoutPayment_planInput
    credit_cards: credit_cardsCreateNestedOneWithoutPayment_planInput
  }

  export type payment_planUncheckedCreateInput = {
    PLAN_ID?: number
    USER_ID: number
    CARD_ID: number
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
  }

  export type payment_planUpdateInput = {
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutPayment_planNestedInput
    credit_cards?: credit_cardsUpdateOneRequiredWithoutPayment_planNestedInput
  }

  export type payment_planUncheckedUpdateInput = {
    PLAN_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: IntFieldUpdateOperationsInput | number
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_planCreateManyInput = {
    PLAN_ID?: number
    USER_ID: number
    CARD_ID: number
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
  }

  export type payment_planUpdateManyMutationInput = {
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_planUncheckedUpdateManyInput = {
    PLAN_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: IntFieldUpdateOperationsInput | number
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateInput = {
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
    users?: usersCreateNestedOneWithoutPaymentsInput
    credit_cards?: credit_cardsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    PAYMENT_ID?: number
    USER_ID?: number | null
    CARD_ID?: number | null
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
  }

  export type paymentsUpdateInput = {
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
    users?: usersUpdateOneWithoutPaymentsNestedInput
    credit_cards?: credit_cardsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    PAYMENT_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
  }

  export type paymentsCreateManyInput = {
    PAYMENT_ID?: number
    USER_ID?: number | null
    CARD_ID?: number | null
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
  }

  export type paymentsUpdateManyMutationInput = {
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    PAYMENT_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
  }

  export type plaidtransactionCreateInput = {
    id: string
    transactionId?: string | null
    name: string
    amount: number
    date: Date | string
    account_id: string
    userId: string
    category?: string | null
    iso_currency_code?: string | null
    createdAt?: Date | string | null
  }

  export type plaidtransactionUncheckedCreateInput = {
    id: string
    transactionId?: string | null
    name: string
    amount: number
    date: Date | string
    account_id: string
    userId: string
    category?: string | null
    iso_currency_code?: string | null
    createdAt?: Date | string | null
  }

  export type plaidtransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    account_id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    iso_currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plaidtransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    account_id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    iso_currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plaidtransactionCreateManyInput = {
    id: string
    transactionId?: string | null
    name: string
    amount: number
    date: Date | string
    account_id: string
    userId: string
    category?: string | null
    iso_currency_code?: string | null
    createdAt?: Date | string | null
  }

  export type plaidtransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    account_id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    iso_currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plaidtransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    account_id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    iso_currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type security_logCreateInput = {
    ACTION: string
    LOG_TIME?: Date | string | null
    users?: usersCreateNestedOneWithoutSecurity_logInput
  }

  export type security_logUncheckedCreateInput = {
    LOG_ID?: number
    USER_ID?: number | null
    ACTION: string
    LOG_TIME?: Date | string | null
  }

  export type security_logUpdateInput = {
    ACTION?: StringFieldUpdateOperationsInput | string
    LOG_TIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutSecurity_logNestedInput
  }

  export type security_logUncheckedUpdateInput = {
    LOG_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ACTION?: StringFieldUpdateOperationsInput | string
    LOG_TIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type security_logCreateManyInput = {
    LOG_ID?: number
    USER_ID?: number | null
    ACTION: string
    LOG_TIME?: Date | string | null
  }

  export type security_logUpdateManyMutationInput = {
    ACTION?: StringFieldUpdateOperationsInput | string
    LOG_TIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type security_logUncheckedUpdateManyInput = {
    LOG_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ACTION?: StringFieldUpdateOperationsInput | string
    LOG_TIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settlementsCreateInput = {
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
    credit_cards?: credit_cardsCreateNestedOneWithoutSettlementsInput
    users?: usersCreateNestedOneWithoutSettlementsInput
  }

  export type settlementsUncheckedCreateInput = {
    SET_ID?: number
    USER_ID?: number | null
    CARD_ID?: number | null
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
  }

  export type settlementsUpdateInput = {
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
    credit_cards?: credit_cardsUpdateOneWithoutSettlementsNestedInput
    users?: usersUpdateOneWithoutSettlementsNestedInput
  }

  export type settlementsUncheckedUpdateInput = {
    SET_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
  }

  export type settlementsCreateManyInput = {
    SET_ID?: number
    USER_ID?: number | null
    CARD_ID?: number | null
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
  }

  export type settlementsUpdateManyMutationInput = {
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
  }

  export type settlementsUncheckedUpdateManyInput = {
    SET_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
  }

  export type transactionsCreateInput = {
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE
    AMOUNT: Decimal | DecimalJsLike | number | string
    MERCHANT?: string | null
    TRANS_DATE?: Date | string | null
    credit_cards?: credit_cardsCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateInput = {
    TRANS_ID?: number
    CARD_ID?: number | null
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE
    AMOUNT: Decimal | DecimalJsLike | number | string
    MERCHANT?: string | null
    TRANS_DATE?: Date | string | null
  }

  export type transactionsUpdateInput = {
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    MERCHANT?: NullableStringFieldUpdateOperationsInput | string | null
    TRANS_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credit_cards?: credit_cardsUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateInput = {
    TRANS_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    MERCHANT?: NullableStringFieldUpdateOperationsInput | string | null
    TRANS_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionsCreateManyInput = {
    TRANS_ID?: number
    CARD_ID?: number | null
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE
    AMOUNT: Decimal | DecimalJsLike | number | string
    MERCHANT?: string | null
    TRANS_DATE?: Date | string | null
  }

  export type transactionsUpdateManyMutationInput = {
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    MERCHANT?: NullableStringFieldUpdateOperationsInput | string | null
    TRANS_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionsUncheckedUpdateManyInput = {
    TRANS_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    MERCHANT?: NullableStringFieldUpdateOperationsInput | string | null
    TRANS_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_sessionCreateInput = {
    SESSION_TOKEN: string
    EXPIRES: Date | string
    users?: usersCreateNestedOneWithoutUser_sessionInput
  }

  export type user_sessionUncheckedCreateInput = {
    SESSION_ID?: number
    USER_ID?: number | null
    SESSION_TOKEN: string
    EXPIRES: Date | string
  }

  export type user_sessionUpdateInput = {
    SESSION_TOKEN?: StringFieldUpdateOperationsInput | string
    EXPIRES?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutUser_sessionNestedInput
  }

  export type user_sessionUncheckedUpdateInput = {
    SESSION_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    SESSION_TOKEN?: StringFieldUpdateOperationsInput | string
    EXPIRES?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionCreateManyInput = {
    SESSION_ID?: number
    USER_ID?: number | null
    SESSION_TOKEN: string
    EXPIRES: Date | string
  }

  export type user_sessionUpdateManyMutationInput = {
    SESSION_TOKEN?: StringFieldUpdateOperationsInput | string
    EXPIRES?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionUncheckedUpdateManyInput = {
    SESSION_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    SESSION_TOKEN?: StringFieldUpdateOperationsInput | string
    EXPIRES?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userplaiditemCreateInput = {
    id: string
    userId: string
    itemId: string
    encryptedAccessToken: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type userplaiditemUncheckedCreateInput = {
    id: string
    userId: string
    itemId: string
    encryptedAccessToken: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type userplaiditemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    encryptedAccessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userplaiditemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    encryptedAccessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userplaiditemCreateManyInput = {
    id: string
    userId: string
    itemId: string
    encryptedAccessToken: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type userplaiditemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    encryptedAccessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userplaiditemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    encryptedAccessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    security_log?: security_logCreateNestedManyWithoutUsersInput
    settlements?: settlementsCreateNestedManyWithoutUsersInput
    user_session?: user_sessionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsUncheckedCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    security_log?: security_logUncheckedCreateNestedManyWithoutUsersInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutUsersInput
    user_session?: user_sessionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    security_log?: security_logUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUncheckedUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    security_log?: security_logUncheckedUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
  }

  export type usersUpdateManyMutationInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type debt_paymentCreateInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    debt: debtCreateNestedOneWithoutPaymentsInput
  }

  export type debt_paymentUncheckedCreateInput = {
    id?: string
    debtId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debt_paymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: debtUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type debt_paymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debt_paymentCreateManyInput = {
    id?: string
    debtId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debt_paymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debt_paymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debtCreateInput = {
    id?: string
    userId: string
    name: string
    balance: Decimal | DecimalJsLike | number | string
    currentBalance: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    minimumPayment: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    extraPayment?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: debt_paymentCreateNestedManyWithoutDebtInput
  }

  export type debtUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    balance: Decimal | DecimalJsLike | number | string
    currentBalance: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    minimumPayment: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    extraPayment?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: debt_paymentUncheckedCreateNestedManyWithoutDebtInput
  }

  export type debtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extraPayment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: debt_paymentUpdateManyWithoutDebtNestedInput
  }

  export type debtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extraPayment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: debt_paymentUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type debtCreateManyInput = {
    id?: string
    userId: string
    name: string
    balance: Decimal | DecimalJsLike | number | string
    currentBalance: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    minimumPayment: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    extraPayment?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extraPayment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extraPayment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Enumcredit_cards_CARD_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_CARD_TYPE | Enumcredit_cards_CARD_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.credit_cards_CARD_TYPE[]
    notIn?: $Enums.credit_cards_CARD_TYPE[]
    not?: NestedEnumcredit_cards_CARD_TYPEFilter<$PrismaModel> | $Enums.credit_cards_CARD_TYPE
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Enumcredit_cards_STATUSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_STATUS | Enumcredit_cards_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.credit_cards_STATUS[] | null
    notIn?: $Enums.credit_cards_STATUS[] | null
    not?: NestedEnumcredit_cards_STATUSNullableFilter<$PrismaModel> | $Enums.credit_cards_STATUS | null
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type Payment_planListRelationFilter = {
    every?: payment_planWhereInput
    some?: payment_planWhereInput
    none?: payment_planWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type SettlementsListRelationFilter = {
    every?: settlementsWhereInput
    some?: settlementsWhereInput
    none?: settlementsWhereInput
  }

  export type TransactionsListRelationFilter = {
    every?: transactionsWhereInput
    some?: transactionsWhereInput
    none?: transactionsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type payment_planOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type settlementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type credit_cardsOrderByRelevanceInput = {
    fields: credit_cardsOrderByRelevanceFieldEnum | credit_cardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type credit_cardsCountOrderByAggregateInput = {
    CARD_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_NUMBER?: SortOrder
    CARD_TYPE?: SortOrder
    CREDIT_LIMIT?: SortOrder
    BALANCE?: SortOrder
    INTEREST_RATE?: SortOrder
    DUE_DATE?: SortOrder
    STATUS?: SortOrder
  }

  export type credit_cardsAvgOrderByAggregateInput = {
    CARD_ID?: SortOrder
    USER_ID?: SortOrder
    CREDIT_LIMIT?: SortOrder
    BALANCE?: SortOrder
    INTEREST_RATE?: SortOrder
  }

  export type credit_cardsMaxOrderByAggregateInput = {
    CARD_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_NUMBER?: SortOrder
    CARD_TYPE?: SortOrder
    CREDIT_LIMIT?: SortOrder
    BALANCE?: SortOrder
    INTEREST_RATE?: SortOrder
    DUE_DATE?: SortOrder
    STATUS?: SortOrder
  }

  export type credit_cardsMinOrderByAggregateInput = {
    CARD_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_NUMBER?: SortOrder
    CARD_TYPE?: SortOrder
    CREDIT_LIMIT?: SortOrder
    BALANCE?: SortOrder
    INTEREST_RATE?: SortOrder
    DUE_DATE?: SortOrder
    STATUS?: SortOrder
  }

  export type credit_cardsSumOrderByAggregateInput = {
    CARD_ID?: SortOrder
    USER_ID?: SortOrder
    CREDIT_LIMIT?: SortOrder
    BALANCE?: SortOrder
    INTEREST_RATE?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Enumcredit_cards_CARD_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_CARD_TYPE | Enumcredit_cards_CARD_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.credit_cards_CARD_TYPE[]
    notIn?: $Enums.credit_cards_CARD_TYPE[]
    not?: NestedEnumcredit_cards_CARD_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.credit_cards_CARD_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcredit_cards_CARD_TYPEFilter<$PrismaModel>
    _max?: NestedEnumcredit_cards_CARD_TYPEFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Enumcredit_cards_STATUSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_STATUS | Enumcredit_cards_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.credit_cards_STATUS[] | null
    notIn?: $Enums.credit_cards_STATUS[] | null
    not?: NestedEnumcredit_cards_STATUSNullableWithAggregatesFilter<$PrismaModel> | $Enums.credit_cards_STATUS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcredit_cards_STATUSNullableFilter<$PrismaModel>
    _max?: NestedEnumcredit_cards_STATUSNullableFilter<$PrismaModel>
  }

  export type Enumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_plan_CHOSEN_PLAN | Enumpayment_plan_CHOSEN_PLANFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    notIn?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    not?: NestedEnumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel> | $Enums.payment_plan_CHOSEN_PLAN | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Credit_cardsScalarRelationFilter = {
    is?: credit_cardsWhereInput
    isNot?: credit_cardsWhereInput
  }

  export type payment_planCountOrderByAggregateInput = {
    PLAN_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    CHOSEN_PLAN?: SortOrder
    PROGRESS?: SortOrder
    PLAN_START?: SortOrder
    EST_PLAN_FINISH?: SortOrder
  }

  export type payment_planAvgOrderByAggregateInput = {
    PLAN_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    PROGRESS?: SortOrder
  }

  export type payment_planMaxOrderByAggregateInput = {
    PLAN_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    CHOSEN_PLAN?: SortOrder
    PROGRESS?: SortOrder
    PLAN_START?: SortOrder
    EST_PLAN_FINISH?: SortOrder
  }

  export type payment_planMinOrderByAggregateInput = {
    PLAN_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    CHOSEN_PLAN?: SortOrder
    PROGRESS?: SortOrder
    PLAN_START?: SortOrder
    EST_PLAN_FINISH?: SortOrder
  }

  export type payment_planSumOrderByAggregateInput = {
    PLAN_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    PROGRESS?: SortOrder
  }

  export type Enumpayment_plan_CHOSEN_PLANNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_plan_CHOSEN_PLAN | Enumpayment_plan_CHOSEN_PLANFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    notIn?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    not?: NestedEnumpayment_plan_CHOSEN_PLANNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_plan_CHOSEN_PLAN | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Enumpayments_PAYMENT_METHODFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_PAYMENT_METHOD | Enumpayments_PAYMENT_METHODFieldRefInput<$PrismaModel>
    in?: $Enums.payments_PAYMENT_METHOD[]
    notIn?: $Enums.payments_PAYMENT_METHOD[]
    not?: NestedEnumpayments_PAYMENT_METHODFilter<$PrismaModel> | $Enums.payments_PAYMENT_METHOD
  }

  export type Enumpayments_STATUSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_STATUS | Enumpayments_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.payments_STATUS[] | null
    notIn?: $Enums.payments_STATUS[] | null
    not?: NestedEnumpayments_STATUSNullableFilter<$PrismaModel> | $Enums.payments_STATUS | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type Credit_cardsNullableScalarRelationFilter = {
    is?: credit_cardsWhereInput | null
    isNot?: credit_cardsWhereInput | null
  }

  export type paymentsCountOrderByAggregateInput = {
    PAYMENT_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    PAID?: SortOrder
    PAYMENT_DATE?: SortOrder
    PAYMENT_METHOD?: SortOrder
    STATUS?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    PAYMENT_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    PAID?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    PAYMENT_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    PAID?: SortOrder
    PAYMENT_DATE?: SortOrder
    PAYMENT_METHOD?: SortOrder
    STATUS?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    PAYMENT_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    PAID?: SortOrder
    PAYMENT_DATE?: SortOrder
    PAYMENT_METHOD?: SortOrder
    STATUS?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    PAYMENT_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    PAID?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enumpayments_PAYMENT_METHODWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_PAYMENT_METHOD | Enumpayments_PAYMENT_METHODFieldRefInput<$PrismaModel>
    in?: $Enums.payments_PAYMENT_METHOD[]
    notIn?: $Enums.payments_PAYMENT_METHOD[]
    not?: NestedEnumpayments_PAYMENT_METHODWithAggregatesFilter<$PrismaModel> | $Enums.payments_PAYMENT_METHOD
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_PAYMENT_METHODFilter<$PrismaModel>
    _max?: NestedEnumpayments_PAYMENT_METHODFilter<$PrismaModel>
  }

  export type Enumpayments_STATUSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_STATUS | Enumpayments_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.payments_STATUS[] | null
    notIn?: $Enums.payments_STATUS[] | null
    not?: NestedEnumpayments_STATUSNullableWithAggregatesFilter<$PrismaModel> | $Enums.payments_STATUS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayments_STATUSNullableFilter<$PrismaModel>
    _max?: NestedEnumpayments_STATUSNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type plaidtransactionOrderByRelevanceInput = {
    fields: plaidtransactionOrderByRelevanceFieldEnum | plaidtransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type plaidtransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    account_id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    iso_currency_code?: SortOrder
    createdAt?: SortOrder
  }

  export type plaidtransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type plaidtransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    account_id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    iso_currency_code?: SortOrder
    createdAt?: SortOrder
  }

  export type plaidtransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    account_id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    iso_currency_code?: SortOrder
    createdAt?: SortOrder
  }

  export type plaidtransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type security_logOrderByRelevanceInput = {
    fields: security_logOrderByRelevanceFieldEnum | security_logOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type security_logCountOrderByAggregateInput = {
    LOG_ID?: SortOrder
    USER_ID?: SortOrder
    ACTION?: SortOrder
    LOG_TIME?: SortOrder
  }

  export type security_logAvgOrderByAggregateInput = {
    LOG_ID?: SortOrder
    USER_ID?: SortOrder
  }

  export type security_logMaxOrderByAggregateInput = {
    LOG_ID?: SortOrder
    USER_ID?: SortOrder
    ACTION?: SortOrder
    LOG_TIME?: SortOrder
  }

  export type security_logMinOrderByAggregateInput = {
    LOG_ID?: SortOrder
    USER_ID?: SortOrder
    ACTION?: SortOrder
    LOG_TIME?: SortOrder
  }

  export type security_logSumOrderByAggregateInput = {
    LOG_ID?: SortOrder
    USER_ID?: SortOrder
  }

  export type Enumsettlements_STATUSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.settlements_STATUS | Enumsettlements_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.settlements_STATUS[] | null
    notIn?: $Enums.settlements_STATUS[] | null
    not?: NestedEnumsettlements_STATUSNullableFilter<$PrismaModel> | $Enums.settlements_STATUS | null
  }

  export type settlementsCountOrderByAggregateInput = {
    SET_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    ORIGINAL_AMOUNT?: SortOrder
    SETTLED_AMOUNT?: SortOrder
    SET_DATE?: SortOrder
    STATUS?: SortOrder
  }

  export type settlementsAvgOrderByAggregateInput = {
    SET_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    ORIGINAL_AMOUNT?: SortOrder
    SETTLED_AMOUNT?: SortOrder
  }

  export type settlementsMaxOrderByAggregateInput = {
    SET_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    ORIGINAL_AMOUNT?: SortOrder
    SETTLED_AMOUNT?: SortOrder
    SET_DATE?: SortOrder
    STATUS?: SortOrder
  }

  export type settlementsMinOrderByAggregateInput = {
    SET_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    ORIGINAL_AMOUNT?: SortOrder
    SETTLED_AMOUNT?: SortOrder
    SET_DATE?: SortOrder
    STATUS?: SortOrder
  }

  export type settlementsSumOrderByAggregateInput = {
    SET_ID?: SortOrder
    USER_ID?: SortOrder
    CARD_ID?: SortOrder
    ORIGINAL_AMOUNT?: SortOrder
    SETTLED_AMOUNT?: SortOrder
  }

  export type Enumsettlements_STATUSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.settlements_STATUS | Enumsettlements_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.settlements_STATUS[] | null
    notIn?: $Enums.settlements_STATUS[] | null
    not?: NestedEnumsettlements_STATUSNullableWithAggregatesFilter<$PrismaModel> | $Enums.settlements_STATUS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsettlements_STATUSNullableFilter<$PrismaModel>
    _max?: NestedEnumsettlements_STATUSNullableFilter<$PrismaModel>
  }

  export type Enumtransactions_TRANS_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.transactions_TRANS_TYPE | Enumtransactions_TRANS_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.transactions_TRANS_TYPE[]
    notIn?: $Enums.transactions_TRANS_TYPE[]
    not?: NestedEnumtransactions_TRANS_TYPEFilter<$PrismaModel> | $Enums.transactions_TRANS_TYPE
  }

  export type transactionsOrderByRelevanceInput = {
    fields: transactionsOrderByRelevanceFieldEnum | transactionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type transactionsCountOrderByAggregateInput = {
    TRANS_ID?: SortOrder
    CARD_ID?: SortOrder
    TRANS_TYPE?: SortOrder
    AMOUNT?: SortOrder
    MERCHANT?: SortOrder
    TRANS_DATE?: SortOrder
  }

  export type transactionsAvgOrderByAggregateInput = {
    TRANS_ID?: SortOrder
    CARD_ID?: SortOrder
    AMOUNT?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    TRANS_ID?: SortOrder
    CARD_ID?: SortOrder
    TRANS_TYPE?: SortOrder
    AMOUNT?: SortOrder
    MERCHANT?: SortOrder
    TRANS_DATE?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    TRANS_ID?: SortOrder
    CARD_ID?: SortOrder
    TRANS_TYPE?: SortOrder
    AMOUNT?: SortOrder
    MERCHANT?: SortOrder
    TRANS_DATE?: SortOrder
  }

  export type transactionsSumOrderByAggregateInput = {
    TRANS_ID?: SortOrder
    CARD_ID?: SortOrder
    AMOUNT?: SortOrder
  }

  export type Enumtransactions_TRANS_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transactions_TRANS_TYPE | Enumtransactions_TRANS_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.transactions_TRANS_TYPE[]
    notIn?: $Enums.transactions_TRANS_TYPE[]
    not?: NestedEnumtransactions_TRANS_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.transactions_TRANS_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransactions_TRANS_TYPEFilter<$PrismaModel>
    _max?: NestedEnumtransactions_TRANS_TYPEFilter<$PrismaModel>
  }

  export type user_sessionOrderByRelevanceInput = {
    fields: user_sessionOrderByRelevanceFieldEnum | user_sessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_sessionCountOrderByAggregateInput = {
    SESSION_ID?: SortOrder
    USER_ID?: SortOrder
    SESSION_TOKEN?: SortOrder
    EXPIRES?: SortOrder
  }

  export type user_sessionAvgOrderByAggregateInput = {
    SESSION_ID?: SortOrder
    USER_ID?: SortOrder
  }

  export type user_sessionMaxOrderByAggregateInput = {
    SESSION_ID?: SortOrder
    USER_ID?: SortOrder
    SESSION_TOKEN?: SortOrder
    EXPIRES?: SortOrder
  }

  export type user_sessionMinOrderByAggregateInput = {
    SESSION_ID?: SortOrder
    USER_ID?: SortOrder
    SESSION_TOKEN?: SortOrder
    EXPIRES?: SortOrder
  }

  export type user_sessionSumOrderByAggregateInput = {
    SESSION_ID?: SortOrder
    USER_ID?: SortOrder
  }

  export type userplaiditemOrderByRelevanceInput = {
    fields: userplaiditemOrderByRelevanceFieldEnum | userplaiditemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userplaiditemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    encryptedAccessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userplaiditemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    encryptedAccessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userplaiditemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    encryptedAccessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Credit_cardsListRelationFilter = {
    every?: credit_cardsWhereInput
    some?: credit_cardsWhereInput
    none?: credit_cardsWhereInput
  }

  export type Security_logListRelationFilter = {
    every?: security_logWhereInput
    some?: security_logWhereInput
    none?: security_logWhereInput
  }

  export type User_sessionListRelationFilter = {
    every?: user_sessionWhereInput
    some?: user_sessionWhereInput
    none?: user_sessionWhereInput
  }

  export type credit_cardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type security_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    USER_ID?: SortOrder
    PASS?: SortOrder
    USER_LNAME?: SortOrder
    USER_FNAME?: SortOrder
    STREET?: SortOrder
    CITY?: SortOrder
    STATE?: SortOrder
    ZIP?: SortOrder
    GENDER?: SortOrder
    PHONE?: SortOrder
    EMAIL?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    USER_ID?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    USER_ID?: SortOrder
    PASS?: SortOrder
    USER_LNAME?: SortOrder
    USER_FNAME?: SortOrder
    STREET?: SortOrder
    CITY?: SortOrder
    STATE?: SortOrder
    ZIP?: SortOrder
    GENDER?: SortOrder
    PHONE?: SortOrder
    EMAIL?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    USER_ID?: SortOrder
    PASS?: SortOrder
    USER_LNAME?: SortOrder
    USER_FNAME?: SortOrder
    STREET?: SortOrder
    CITY?: SortOrder
    STATE?: SortOrder
    ZIP?: SortOrder
    GENDER?: SortOrder
    PHONE?: SortOrder
    EMAIL?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    USER_ID?: SortOrder
  }

  export type DebtScalarRelationFilter = {
    is?: debtWhereInput
    isNot?: debtWhereInput
  }

  export type debt_paymentOrderByRelevanceInput = {
    fields: debt_paymentOrderByRelevanceFieldEnum | debt_paymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type debt_paymentCountOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type debt_paymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type debt_paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type debt_paymentMinOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type debt_paymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Debt_paymentListRelationFilter = {
    every?: debt_paymentWhereInput
    some?: debt_paymentWhereInput
    none?: debt_paymentWhereInput
  }

  export type debt_paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type debtOrderByRelevanceInput = {
    fields: debtOrderByRelevanceFieldEnum | debtOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type debtCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    currentBalance?: SortOrder
    interestRate?: SortOrder
    minimumPayment?: SortOrder
    dueDate?: SortOrder
    extraPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type debtAvgOrderByAggregateInput = {
    balance?: SortOrder
    currentBalance?: SortOrder
    interestRate?: SortOrder
    minimumPayment?: SortOrder
    extraPayment?: SortOrder
  }

  export type debtMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    currentBalance?: SortOrder
    interestRate?: SortOrder
    minimumPayment?: SortOrder
    dueDate?: SortOrder
    extraPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type debtMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    currentBalance?: SortOrder
    interestRate?: SortOrder
    minimumPayment?: SortOrder
    dueDate?: SortOrder
    extraPayment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type debtSumOrderByAggregateInput = {
    balance?: SortOrder
    currentBalance?: SortOrder
    interestRate?: SortOrder
    minimumPayment?: SortOrder
    extraPayment?: SortOrder
  }

  export type usersCreateNestedOneWithoutCredit_cardsInput = {
    create?: XOR<usersCreateWithoutCredit_cardsInput, usersUncheckedCreateWithoutCredit_cardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCredit_cardsInput
    connect?: usersWhereUniqueInput
  }

  export type payment_planCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<payment_planCreateWithoutCredit_cardsInput, payment_planUncheckedCreateWithoutCredit_cardsInput> | payment_planCreateWithoutCredit_cardsInput[] | payment_planUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutCredit_cardsInput | payment_planCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: payment_planCreateManyCredit_cardsInputEnvelope
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<paymentsCreateWithoutCredit_cardsInput, paymentsUncheckedCreateWithoutCredit_cardsInput> | paymentsCreateWithoutCredit_cardsInput[] | paymentsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCredit_cardsInput | paymentsCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: paymentsCreateManyCredit_cardsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type settlementsCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<settlementsCreateWithoutCredit_cardsInput, settlementsUncheckedCreateWithoutCredit_cardsInput> | settlementsCreateWithoutCredit_cardsInput[] | settlementsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutCredit_cardsInput | settlementsCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: settlementsCreateManyCredit_cardsInputEnvelope
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
  }

  export type transactionsCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<transactionsCreateWithoutCredit_cardsInput, transactionsUncheckedCreateWithoutCredit_cardsInput> | transactionsCreateWithoutCredit_cardsInput[] | transactionsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCredit_cardsInput | transactionsCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: transactionsCreateManyCredit_cardsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type payment_planUncheckedCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<payment_planCreateWithoutCredit_cardsInput, payment_planUncheckedCreateWithoutCredit_cardsInput> | payment_planCreateWithoutCredit_cardsInput[] | payment_planUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutCredit_cardsInput | payment_planCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: payment_planCreateManyCredit_cardsInputEnvelope
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<paymentsCreateWithoutCredit_cardsInput, paymentsUncheckedCreateWithoutCredit_cardsInput> | paymentsCreateWithoutCredit_cardsInput[] | paymentsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCredit_cardsInput | paymentsCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: paymentsCreateManyCredit_cardsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type settlementsUncheckedCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<settlementsCreateWithoutCredit_cardsInput, settlementsUncheckedCreateWithoutCredit_cardsInput> | settlementsCreateWithoutCredit_cardsInput[] | settlementsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutCredit_cardsInput | settlementsCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: settlementsCreateManyCredit_cardsInputEnvelope
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutCredit_cardsInput = {
    create?: XOR<transactionsCreateWithoutCredit_cardsInput, transactionsUncheckedCreateWithoutCredit_cardsInput> | transactionsCreateWithoutCredit_cardsInput[] | transactionsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCredit_cardsInput | transactionsCreateOrConnectWithoutCredit_cardsInput[]
    createMany?: transactionsCreateManyCredit_cardsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput = {
    set?: $Enums.credit_cards_CARD_TYPE
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput = {
    set?: $Enums.credit_cards_STATUS | null
  }

  export type usersUpdateOneRequiredWithoutCredit_cardsNestedInput = {
    create?: XOR<usersCreateWithoutCredit_cardsInput, usersUncheckedCreateWithoutCredit_cardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCredit_cardsInput
    upsert?: usersUpsertWithoutCredit_cardsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCredit_cardsInput, usersUpdateWithoutCredit_cardsInput>, usersUncheckedUpdateWithoutCredit_cardsInput>
  }

  export type payment_planUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<payment_planCreateWithoutCredit_cardsInput, payment_planUncheckedCreateWithoutCredit_cardsInput> | payment_planCreateWithoutCredit_cardsInput[] | payment_planUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutCredit_cardsInput | payment_planCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: payment_planUpsertWithWhereUniqueWithoutCredit_cardsInput | payment_planUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: payment_planCreateManyCredit_cardsInputEnvelope
    set?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    disconnect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    delete?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    update?: payment_planUpdateWithWhereUniqueWithoutCredit_cardsInput | payment_planUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: payment_planUpdateManyWithWhereWithoutCredit_cardsInput | payment_planUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: payment_planScalarWhereInput | payment_planScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<paymentsCreateWithoutCredit_cardsInput, paymentsUncheckedCreateWithoutCredit_cardsInput> | paymentsCreateWithoutCredit_cardsInput[] | paymentsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCredit_cardsInput | paymentsCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCredit_cardsInput | paymentsUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: paymentsCreateManyCredit_cardsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCredit_cardsInput | paymentsUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCredit_cardsInput | paymentsUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type settlementsUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<settlementsCreateWithoutCredit_cardsInput, settlementsUncheckedCreateWithoutCredit_cardsInput> | settlementsCreateWithoutCredit_cardsInput[] | settlementsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutCredit_cardsInput | settlementsCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: settlementsUpsertWithWhereUniqueWithoutCredit_cardsInput | settlementsUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: settlementsCreateManyCredit_cardsInputEnvelope
    set?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    disconnect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    delete?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    update?: settlementsUpdateWithWhereUniqueWithoutCredit_cardsInput | settlementsUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: settlementsUpdateManyWithWhereWithoutCredit_cardsInput | settlementsUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: settlementsScalarWhereInput | settlementsScalarWhereInput[]
  }

  export type transactionsUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<transactionsCreateWithoutCredit_cardsInput, transactionsUncheckedCreateWithoutCredit_cardsInput> | transactionsCreateWithoutCredit_cardsInput[] | transactionsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCredit_cardsInput | transactionsCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutCredit_cardsInput | transactionsUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: transactionsCreateManyCredit_cardsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutCredit_cardsInput | transactionsUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutCredit_cardsInput | transactionsUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type payment_planUncheckedUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<payment_planCreateWithoutCredit_cardsInput, payment_planUncheckedCreateWithoutCredit_cardsInput> | payment_planCreateWithoutCredit_cardsInput[] | payment_planUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutCredit_cardsInput | payment_planCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: payment_planUpsertWithWhereUniqueWithoutCredit_cardsInput | payment_planUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: payment_planCreateManyCredit_cardsInputEnvelope
    set?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    disconnect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    delete?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    update?: payment_planUpdateWithWhereUniqueWithoutCredit_cardsInput | payment_planUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: payment_planUpdateManyWithWhereWithoutCredit_cardsInput | payment_planUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: payment_planScalarWhereInput | payment_planScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<paymentsCreateWithoutCredit_cardsInput, paymentsUncheckedCreateWithoutCredit_cardsInput> | paymentsCreateWithoutCredit_cardsInput[] | paymentsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCredit_cardsInput | paymentsCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCredit_cardsInput | paymentsUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: paymentsCreateManyCredit_cardsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCredit_cardsInput | paymentsUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCredit_cardsInput | paymentsUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type settlementsUncheckedUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<settlementsCreateWithoutCredit_cardsInput, settlementsUncheckedCreateWithoutCredit_cardsInput> | settlementsCreateWithoutCredit_cardsInput[] | settlementsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutCredit_cardsInput | settlementsCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: settlementsUpsertWithWhereUniqueWithoutCredit_cardsInput | settlementsUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: settlementsCreateManyCredit_cardsInputEnvelope
    set?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    disconnect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    delete?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    update?: settlementsUpdateWithWhereUniqueWithoutCredit_cardsInput | settlementsUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: settlementsUpdateManyWithWhereWithoutCredit_cardsInput | settlementsUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: settlementsScalarWhereInput | settlementsScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutCredit_cardsNestedInput = {
    create?: XOR<transactionsCreateWithoutCredit_cardsInput, transactionsUncheckedCreateWithoutCredit_cardsInput> | transactionsCreateWithoutCredit_cardsInput[] | transactionsUncheckedCreateWithoutCredit_cardsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCredit_cardsInput | transactionsCreateOrConnectWithoutCredit_cardsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutCredit_cardsInput | transactionsUpsertWithWhereUniqueWithoutCredit_cardsInput[]
    createMany?: transactionsCreateManyCredit_cardsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutCredit_cardsInput | transactionsUpdateWithWhereUniqueWithoutCredit_cardsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutCredit_cardsInput | transactionsUpdateManyWithWhereWithoutCredit_cardsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutPayment_planInput = {
    create?: XOR<usersCreateWithoutPayment_planInput, usersUncheckedCreateWithoutPayment_planInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayment_planInput
    connect?: usersWhereUniqueInput
  }

  export type credit_cardsCreateNestedOneWithoutPayment_planInput = {
    create?: XOR<credit_cardsCreateWithoutPayment_planInput, credit_cardsUncheckedCreateWithoutPayment_planInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutPayment_planInput
    connect?: credit_cardsWhereUniqueInput
  }

  export type NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput = {
    set?: $Enums.payment_plan_CHOSEN_PLAN | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usersUpdateOneRequiredWithoutPayment_planNestedInput = {
    create?: XOR<usersCreateWithoutPayment_planInput, usersUncheckedCreateWithoutPayment_planInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayment_planInput
    upsert?: usersUpsertWithoutPayment_planInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPayment_planInput, usersUpdateWithoutPayment_planInput>, usersUncheckedUpdateWithoutPayment_planInput>
  }

  export type credit_cardsUpdateOneRequiredWithoutPayment_planNestedInput = {
    create?: XOR<credit_cardsCreateWithoutPayment_planInput, credit_cardsUncheckedCreateWithoutPayment_planInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutPayment_planInput
    upsert?: credit_cardsUpsertWithoutPayment_planInput
    connect?: credit_cardsWhereUniqueInput
    update?: XOR<XOR<credit_cardsUpdateToOneWithWhereWithoutPayment_planInput, credit_cardsUpdateWithoutPayment_planInput>, credit_cardsUncheckedUpdateWithoutPayment_planInput>
  }

  export type usersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    connect?: usersWhereUniqueInput
  }

  export type credit_cardsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<credit_cardsCreateWithoutPaymentsInput, credit_cardsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutPaymentsInput
    connect?: credit_cardsWhereUniqueInput
  }

  export type Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput = {
    set?: $Enums.payments_PAYMENT_METHOD
  }

  export type NullableEnumpayments_STATUSFieldUpdateOperationsInput = {
    set?: $Enums.payments_STATUS | null
  }

  export type usersUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    upsert?: usersUpsertWithoutPaymentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPaymentsInput, usersUpdateWithoutPaymentsInput>, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type credit_cardsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<credit_cardsCreateWithoutPaymentsInput, credit_cardsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutPaymentsInput
    upsert?: credit_cardsUpsertWithoutPaymentsInput
    disconnect?: credit_cardsWhereInput | boolean
    delete?: credit_cardsWhereInput | boolean
    connect?: credit_cardsWhereUniqueInput
    update?: XOR<XOR<credit_cardsUpdateToOneWithWhereWithoutPaymentsInput, credit_cardsUpdateWithoutPaymentsInput>, credit_cardsUncheckedUpdateWithoutPaymentsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersCreateNestedOneWithoutSecurity_logInput = {
    create?: XOR<usersCreateWithoutSecurity_logInput, usersUncheckedCreateWithoutSecurity_logInput>
    connectOrCreate?: usersCreateOrConnectWithoutSecurity_logInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutSecurity_logNestedInput = {
    create?: XOR<usersCreateWithoutSecurity_logInput, usersUncheckedCreateWithoutSecurity_logInput>
    connectOrCreate?: usersCreateOrConnectWithoutSecurity_logInput
    upsert?: usersUpsertWithoutSecurity_logInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSecurity_logInput, usersUpdateWithoutSecurity_logInput>, usersUncheckedUpdateWithoutSecurity_logInput>
  }

  export type credit_cardsCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<credit_cardsCreateWithoutSettlementsInput, credit_cardsUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutSettlementsInput
    connect?: credit_cardsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<usersCreateWithoutSettlementsInput, usersUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSettlementsInput
    connect?: usersWhereUniqueInput
  }

  export type NullableEnumsettlements_STATUSFieldUpdateOperationsInput = {
    set?: $Enums.settlements_STATUS | null
  }

  export type credit_cardsUpdateOneWithoutSettlementsNestedInput = {
    create?: XOR<credit_cardsCreateWithoutSettlementsInput, credit_cardsUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutSettlementsInput
    upsert?: credit_cardsUpsertWithoutSettlementsInput
    disconnect?: credit_cardsWhereInput | boolean
    delete?: credit_cardsWhereInput | boolean
    connect?: credit_cardsWhereUniqueInput
    update?: XOR<XOR<credit_cardsUpdateToOneWithWhereWithoutSettlementsInput, credit_cardsUpdateWithoutSettlementsInput>, credit_cardsUncheckedUpdateWithoutSettlementsInput>
  }

  export type usersUpdateOneWithoutSettlementsNestedInput = {
    create?: XOR<usersCreateWithoutSettlementsInput, usersUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSettlementsInput
    upsert?: usersUpsertWithoutSettlementsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSettlementsInput, usersUpdateWithoutSettlementsInput>, usersUncheckedUpdateWithoutSettlementsInput>
  }

  export type credit_cardsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<credit_cardsCreateWithoutTransactionsInput, credit_cardsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutTransactionsInput
    connect?: credit_cardsWhereUniqueInput
  }

  export type Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput = {
    set?: $Enums.transactions_TRANS_TYPE
  }

  export type credit_cardsUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<credit_cardsCreateWithoutTransactionsInput, credit_cardsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: credit_cardsCreateOrConnectWithoutTransactionsInput
    upsert?: credit_cardsUpsertWithoutTransactionsInput
    disconnect?: credit_cardsWhereInput | boolean
    delete?: credit_cardsWhereInput | boolean
    connect?: credit_cardsWhereUniqueInput
    update?: XOR<XOR<credit_cardsUpdateToOneWithWhereWithoutTransactionsInput, credit_cardsUpdateWithoutTransactionsInput>, credit_cardsUncheckedUpdateWithoutTransactionsInput>
  }

  export type usersCreateNestedOneWithoutUser_sessionInput = {
    create?: XOR<usersCreateWithoutUser_sessionInput, usersUncheckedCreateWithoutUser_sessionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_sessionInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutUser_sessionNestedInput = {
    create?: XOR<usersCreateWithoutUser_sessionInput, usersUncheckedCreateWithoutUser_sessionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_sessionInput
    upsert?: usersUpsertWithoutUser_sessionInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_sessionInput, usersUpdateWithoutUser_sessionInput>, usersUncheckedUpdateWithoutUser_sessionInput>
  }

  export type credit_cardsCreateNestedManyWithoutUsersInput = {
    create?: XOR<credit_cardsCreateWithoutUsersInput, credit_cardsUncheckedCreateWithoutUsersInput> | credit_cardsCreateWithoutUsersInput[] | credit_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: credit_cardsCreateOrConnectWithoutUsersInput | credit_cardsCreateOrConnectWithoutUsersInput[]
    createMany?: credit_cardsCreateManyUsersInputEnvelope
    connect?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
  }

  export type payment_planCreateNestedManyWithoutUsersInput = {
    create?: XOR<payment_planCreateWithoutUsersInput, payment_planUncheckedCreateWithoutUsersInput> | payment_planCreateWithoutUsersInput[] | payment_planUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutUsersInput | payment_planCreateOrConnectWithoutUsersInput[]
    createMany?: payment_planCreateManyUsersInputEnvelope
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type security_logCreateNestedManyWithoutUsersInput = {
    create?: XOR<security_logCreateWithoutUsersInput, security_logUncheckedCreateWithoutUsersInput> | security_logCreateWithoutUsersInput[] | security_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: security_logCreateOrConnectWithoutUsersInput | security_logCreateOrConnectWithoutUsersInput[]
    createMany?: security_logCreateManyUsersInputEnvelope
    connect?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
  }

  export type settlementsCreateNestedManyWithoutUsersInput = {
    create?: XOR<settlementsCreateWithoutUsersInput, settlementsUncheckedCreateWithoutUsersInput> | settlementsCreateWithoutUsersInput[] | settlementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutUsersInput | settlementsCreateOrConnectWithoutUsersInput[]
    createMany?: settlementsCreateManyUsersInputEnvelope
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
  }

  export type user_sessionCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_sessionCreateWithoutUsersInput, user_sessionUncheckedCreateWithoutUsersInput> | user_sessionCreateWithoutUsersInput[] | user_sessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionCreateOrConnectWithoutUsersInput | user_sessionCreateOrConnectWithoutUsersInput[]
    createMany?: user_sessionCreateManyUsersInputEnvelope
    connect?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
  }

  export type credit_cardsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<credit_cardsCreateWithoutUsersInput, credit_cardsUncheckedCreateWithoutUsersInput> | credit_cardsCreateWithoutUsersInput[] | credit_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: credit_cardsCreateOrConnectWithoutUsersInput | credit_cardsCreateOrConnectWithoutUsersInput[]
    createMany?: credit_cardsCreateManyUsersInputEnvelope
    connect?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
  }

  export type payment_planUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<payment_planCreateWithoutUsersInput, payment_planUncheckedCreateWithoutUsersInput> | payment_planCreateWithoutUsersInput[] | payment_planUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutUsersInput | payment_planCreateOrConnectWithoutUsersInput[]
    createMany?: payment_planCreateManyUsersInputEnvelope
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type security_logUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<security_logCreateWithoutUsersInput, security_logUncheckedCreateWithoutUsersInput> | security_logCreateWithoutUsersInput[] | security_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: security_logCreateOrConnectWithoutUsersInput | security_logCreateOrConnectWithoutUsersInput[]
    createMany?: security_logCreateManyUsersInputEnvelope
    connect?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
  }

  export type settlementsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<settlementsCreateWithoutUsersInput, settlementsUncheckedCreateWithoutUsersInput> | settlementsCreateWithoutUsersInput[] | settlementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutUsersInput | settlementsCreateOrConnectWithoutUsersInput[]
    createMany?: settlementsCreateManyUsersInputEnvelope
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
  }

  export type user_sessionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_sessionCreateWithoutUsersInput, user_sessionUncheckedCreateWithoutUsersInput> | user_sessionCreateWithoutUsersInput[] | user_sessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionCreateOrConnectWithoutUsersInput | user_sessionCreateOrConnectWithoutUsersInput[]
    createMany?: user_sessionCreateManyUsersInputEnvelope
    connect?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
  }

  export type credit_cardsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<credit_cardsCreateWithoutUsersInput, credit_cardsUncheckedCreateWithoutUsersInput> | credit_cardsCreateWithoutUsersInput[] | credit_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: credit_cardsCreateOrConnectWithoutUsersInput | credit_cardsCreateOrConnectWithoutUsersInput[]
    upsert?: credit_cardsUpsertWithWhereUniqueWithoutUsersInput | credit_cardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: credit_cardsCreateManyUsersInputEnvelope
    set?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    disconnect?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    delete?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    connect?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    update?: credit_cardsUpdateWithWhereUniqueWithoutUsersInput | credit_cardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: credit_cardsUpdateManyWithWhereWithoutUsersInput | credit_cardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: credit_cardsScalarWhereInput | credit_cardsScalarWhereInput[]
  }

  export type payment_planUpdateManyWithoutUsersNestedInput = {
    create?: XOR<payment_planCreateWithoutUsersInput, payment_planUncheckedCreateWithoutUsersInput> | payment_planCreateWithoutUsersInput[] | payment_planUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutUsersInput | payment_planCreateOrConnectWithoutUsersInput[]
    upsert?: payment_planUpsertWithWhereUniqueWithoutUsersInput | payment_planUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: payment_planCreateManyUsersInputEnvelope
    set?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    disconnect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    delete?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    update?: payment_planUpdateWithWhereUniqueWithoutUsersInput | payment_planUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: payment_planUpdateManyWithWhereWithoutUsersInput | payment_planUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: payment_planScalarWhereInput | payment_planScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type security_logUpdateManyWithoutUsersNestedInput = {
    create?: XOR<security_logCreateWithoutUsersInput, security_logUncheckedCreateWithoutUsersInput> | security_logCreateWithoutUsersInput[] | security_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: security_logCreateOrConnectWithoutUsersInput | security_logCreateOrConnectWithoutUsersInput[]
    upsert?: security_logUpsertWithWhereUniqueWithoutUsersInput | security_logUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: security_logCreateManyUsersInputEnvelope
    set?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    disconnect?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    delete?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    connect?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    update?: security_logUpdateWithWhereUniqueWithoutUsersInput | security_logUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: security_logUpdateManyWithWhereWithoutUsersInput | security_logUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: security_logScalarWhereInput | security_logScalarWhereInput[]
  }

  export type settlementsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<settlementsCreateWithoutUsersInput, settlementsUncheckedCreateWithoutUsersInput> | settlementsCreateWithoutUsersInput[] | settlementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutUsersInput | settlementsCreateOrConnectWithoutUsersInput[]
    upsert?: settlementsUpsertWithWhereUniqueWithoutUsersInput | settlementsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: settlementsCreateManyUsersInputEnvelope
    set?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    disconnect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    delete?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    update?: settlementsUpdateWithWhereUniqueWithoutUsersInput | settlementsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: settlementsUpdateManyWithWhereWithoutUsersInput | settlementsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: settlementsScalarWhereInput | settlementsScalarWhereInput[]
  }

  export type user_sessionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_sessionCreateWithoutUsersInput, user_sessionUncheckedCreateWithoutUsersInput> | user_sessionCreateWithoutUsersInput[] | user_sessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionCreateOrConnectWithoutUsersInput | user_sessionCreateOrConnectWithoutUsersInput[]
    upsert?: user_sessionUpsertWithWhereUniqueWithoutUsersInput | user_sessionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_sessionCreateManyUsersInputEnvelope
    set?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    disconnect?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    delete?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    connect?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    update?: user_sessionUpdateWithWhereUniqueWithoutUsersInput | user_sessionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_sessionUpdateManyWithWhereWithoutUsersInput | user_sessionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_sessionScalarWhereInput | user_sessionScalarWhereInput[]
  }

  export type credit_cardsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<credit_cardsCreateWithoutUsersInput, credit_cardsUncheckedCreateWithoutUsersInput> | credit_cardsCreateWithoutUsersInput[] | credit_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: credit_cardsCreateOrConnectWithoutUsersInput | credit_cardsCreateOrConnectWithoutUsersInput[]
    upsert?: credit_cardsUpsertWithWhereUniqueWithoutUsersInput | credit_cardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: credit_cardsCreateManyUsersInputEnvelope
    set?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    disconnect?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    delete?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    connect?: credit_cardsWhereUniqueInput | credit_cardsWhereUniqueInput[]
    update?: credit_cardsUpdateWithWhereUniqueWithoutUsersInput | credit_cardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: credit_cardsUpdateManyWithWhereWithoutUsersInput | credit_cardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: credit_cardsScalarWhereInput | credit_cardsScalarWhereInput[]
  }

  export type payment_planUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<payment_planCreateWithoutUsersInput, payment_planUncheckedCreateWithoutUsersInput> | payment_planCreateWithoutUsersInput[] | payment_planUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_planCreateOrConnectWithoutUsersInput | payment_planCreateOrConnectWithoutUsersInput[]
    upsert?: payment_planUpsertWithWhereUniqueWithoutUsersInput | payment_planUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: payment_planCreateManyUsersInputEnvelope
    set?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    disconnect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    delete?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    connect?: payment_planWhereUniqueInput | payment_planWhereUniqueInput[]
    update?: payment_planUpdateWithWhereUniqueWithoutUsersInput | payment_planUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: payment_planUpdateManyWithWhereWithoutUsersInput | payment_planUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: payment_planScalarWhereInput | payment_planScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type security_logUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<security_logCreateWithoutUsersInput, security_logUncheckedCreateWithoutUsersInput> | security_logCreateWithoutUsersInput[] | security_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: security_logCreateOrConnectWithoutUsersInput | security_logCreateOrConnectWithoutUsersInput[]
    upsert?: security_logUpsertWithWhereUniqueWithoutUsersInput | security_logUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: security_logCreateManyUsersInputEnvelope
    set?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    disconnect?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    delete?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    connect?: security_logWhereUniqueInput | security_logWhereUniqueInput[]
    update?: security_logUpdateWithWhereUniqueWithoutUsersInput | security_logUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: security_logUpdateManyWithWhereWithoutUsersInput | security_logUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: security_logScalarWhereInput | security_logScalarWhereInput[]
  }

  export type settlementsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<settlementsCreateWithoutUsersInput, settlementsUncheckedCreateWithoutUsersInput> | settlementsCreateWithoutUsersInput[] | settlementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: settlementsCreateOrConnectWithoutUsersInput | settlementsCreateOrConnectWithoutUsersInput[]
    upsert?: settlementsUpsertWithWhereUniqueWithoutUsersInput | settlementsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: settlementsCreateManyUsersInputEnvelope
    set?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    disconnect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    delete?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    connect?: settlementsWhereUniqueInput | settlementsWhereUniqueInput[]
    update?: settlementsUpdateWithWhereUniqueWithoutUsersInput | settlementsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: settlementsUpdateManyWithWhereWithoutUsersInput | settlementsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: settlementsScalarWhereInput | settlementsScalarWhereInput[]
  }

  export type user_sessionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_sessionCreateWithoutUsersInput, user_sessionUncheckedCreateWithoutUsersInput> | user_sessionCreateWithoutUsersInput[] | user_sessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionCreateOrConnectWithoutUsersInput | user_sessionCreateOrConnectWithoutUsersInput[]
    upsert?: user_sessionUpsertWithWhereUniqueWithoutUsersInput | user_sessionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_sessionCreateManyUsersInputEnvelope
    set?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    disconnect?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    delete?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    connect?: user_sessionWhereUniqueInput | user_sessionWhereUniqueInput[]
    update?: user_sessionUpdateWithWhereUniqueWithoutUsersInput | user_sessionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_sessionUpdateManyWithWhereWithoutUsersInput | user_sessionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_sessionScalarWhereInput | user_sessionScalarWhereInput[]
  }

  export type debtCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<debtCreateWithoutPaymentsInput, debtUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: debtCreateOrConnectWithoutPaymentsInput
    connect?: debtWhereUniqueInput
  }

  export type debtUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<debtCreateWithoutPaymentsInput, debtUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: debtCreateOrConnectWithoutPaymentsInput
    upsert?: debtUpsertWithoutPaymentsInput
    connect?: debtWhereUniqueInput
    update?: XOR<XOR<debtUpdateToOneWithWhereWithoutPaymentsInput, debtUpdateWithoutPaymentsInput>, debtUncheckedUpdateWithoutPaymentsInput>
  }

  export type debt_paymentCreateNestedManyWithoutDebtInput = {
    create?: XOR<debt_paymentCreateWithoutDebtInput, debt_paymentUncheckedCreateWithoutDebtInput> | debt_paymentCreateWithoutDebtInput[] | debt_paymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: debt_paymentCreateOrConnectWithoutDebtInput | debt_paymentCreateOrConnectWithoutDebtInput[]
    createMany?: debt_paymentCreateManyDebtInputEnvelope
    connect?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
  }

  export type debt_paymentUncheckedCreateNestedManyWithoutDebtInput = {
    create?: XOR<debt_paymentCreateWithoutDebtInput, debt_paymentUncheckedCreateWithoutDebtInput> | debt_paymentCreateWithoutDebtInput[] | debt_paymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: debt_paymentCreateOrConnectWithoutDebtInput | debt_paymentCreateOrConnectWithoutDebtInput[]
    createMany?: debt_paymentCreateManyDebtInputEnvelope
    connect?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
  }

  export type debt_paymentUpdateManyWithoutDebtNestedInput = {
    create?: XOR<debt_paymentCreateWithoutDebtInput, debt_paymentUncheckedCreateWithoutDebtInput> | debt_paymentCreateWithoutDebtInput[] | debt_paymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: debt_paymentCreateOrConnectWithoutDebtInput | debt_paymentCreateOrConnectWithoutDebtInput[]
    upsert?: debt_paymentUpsertWithWhereUniqueWithoutDebtInput | debt_paymentUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: debt_paymentCreateManyDebtInputEnvelope
    set?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    disconnect?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    delete?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    connect?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    update?: debt_paymentUpdateWithWhereUniqueWithoutDebtInput | debt_paymentUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: debt_paymentUpdateManyWithWhereWithoutDebtInput | debt_paymentUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: debt_paymentScalarWhereInput | debt_paymentScalarWhereInput[]
  }

  export type debt_paymentUncheckedUpdateManyWithoutDebtNestedInput = {
    create?: XOR<debt_paymentCreateWithoutDebtInput, debt_paymentUncheckedCreateWithoutDebtInput> | debt_paymentCreateWithoutDebtInput[] | debt_paymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: debt_paymentCreateOrConnectWithoutDebtInput | debt_paymentCreateOrConnectWithoutDebtInput[]
    upsert?: debt_paymentUpsertWithWhereUniqueWithoutDebtInput | debt_paymentUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: debt_paymentCreateManyDebtInputEnvelope
    set?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    disconnect?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    delete?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    connect?: debt_paymentWhereUniqueInput | debt_paymentWhereUniqueInput[]
    update?: debt_paymentUpdateWithWhereUniqueWithoutDebtInput | debt_paymentUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: debt_paymentUpdateManyWithWhereWithoutDebtInput | debt_paymentUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: debt_paymentScalarWhereInput | debt_paymentScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumcredit_cards_CARD_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_CARD_TYPE | Enumcredit_cards_CARD_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.credit_cards_CARD_TYPE[]
    notIn?: $Enums.credit_cards_CARD_TYPE[]
    not?: NestedEnumcredit_cards_CARD_TYPEFilter<$PrismaModel> | $Enums.credit_cards_CARD_TYPE
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumcredit_cards_STATUSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_STATUS | Enumcredit_cards_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.credit_cards_STATUS[] | null
    notIn?: $Enums.credit_cards_STATUS[] | null
    not?: NestedEnumcredit_cards_STATUSNullableFilter<$PrismaModel> | $Enums.credit_cards_STATUS | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumcredit_cards_CARD_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_CARD_TYPE | Enumcredit_cards_CARD_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.credit_cards_CARD_TYPE[]
    notIn?: $Enums.credit_cards_CARD_TYPE[]
    not?: NestedEnumcredit_cards_CARD_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.credit_cards_CARD_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcredit_cards_CARD_TYPEFilter<$PrismaModel>
    _max?: NestedEnumcredit_cards_CARD_TYPEFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumcredit_cards_STATUSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.credit_cards_STATUS | Enumcredit_cards_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.credit_cards_STATUS[] | null
    notIn?: $Enums.credit_cards_STATUS[] | null
    not?: NestedEnumcredit_cards_STATUSNullableWithAggregatesFilter<$PrismaModel> | $Enums.credit_cards_STATUS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcredit_cards_STATUSNullableFilter<$PrismaModel>
    _max?: NestedEnumcredit_cards_STATUSNullableFilter<$PrismaModel>
  }

  export type NestedEnumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_plan_CHOSEN_PLAN | Enumpayment_plan_CHOSEN_PLANFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    notIn?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    not?: NestedEnumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel> | $Enums.payment_plan_CHOSEN_PLAN | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumpayment_plan_CHOSEN_PLANNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_plan_CHOSEN_PLAN | Enumpayment_plan_CHOSEN_PLANFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    notIn?: $Enums.payment_plan_CHOSEN_PLAN[] | null
    not?: NestedEnumpayment_plan_CHOSEN_PLANNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_plan_CHOSEN_PLAN | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_plan_CHOSEN_PLANNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumpayments_PAYMENT_METHODFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_PAYMENT_METHOD | Enumpayments_PAYMENT_METHODFieldRefInput<$PrismaModel>
    in?: $Enums.payments_PAYMENT_METHOD[]
    notIn?: $Enums.payments_PAYMENT_METHOD[]
    not?: NestedEnumpayments_PAYMENT_METHODFilter<$PrismaModel> | $Enums.payments_PAYMENT_METHOD
  }

  export type NestedEnumpayments_STATUSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_STATUS | Enumpayments_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.payments_STATUS[] | null
    notIn?: $Enums.payments_STATUS[] | null
    not?: NestedEnumpayments_STATUSNullableFilter<$PrismaModel> | $Enums.payments_STATUS | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumpayments_PAYMENT_METHODWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_PAYMENT_METHOD | Enumpayments_PAYMENT_METHODFieldRefInput<$PrismaModel>
    in?: $Enums.payments_PAYMENT_METHOD[]
    notIn?: $Enums.payments_PAYMENT_METHOD[]
    not?: NestedEnumpayments_PAYMENT_METHODWithAggregatesFilter<$PrismaModel> | $Enums.payments_PAYMENT_METHOD
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_PAYMENT_METHODFilter<$PrismaModel>
    _max?: NestedEnumpayments_PAYMENT_METHODFilter<$PrismaModel>
  }

  export type NestedEnumpayments_STATUSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_STATUS | Enumpayments_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.payments_STATUS[] | null
    notIn?: $Enums.payments_STATUS[] | null
    not?: NestedEnumpayments_STATUSNullableWithAggregatesFilter<$PrismaModel> | $Enums.payments_STATUS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayments_STATUSNullableFilter<$PrismaModel>
    _max?: NestedEnumpayments_STATUSNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumsettlements_STATUSNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.settlements_STATUS | Enumsettlements_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.settlements_STATUS[] | null
    notIn?: $Enums.settlements_STATUS[] | null
    not?: NestedEnumsettlements_STATUSNullableFilter<$PrismaModel> | $Enums.settlements_STATUS | null
  }

  export type NestedEnumsettlements_STATUSNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.settlements_STATUS | Enumsettlements_STATUSFieldRefInput<$PrismaModel> | null
    in?: $Enums.settlements_STATUS[] | null
    notIn?: $Enums.settlements_STATUS[] | null
    not?: NestedEnumsettlements_STATUSNullableWithAggregatesFilter<$PrismaModel> | $Enums.settlements_STATUS | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsettlements_STATUSNullableFilter<$PrismaModel>
    _max?: NestedEnumsettlements_STATUSNullableFilter<$PrismaModel>
  }

  export type NestedEnumtransactions_TRANS_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.transactions_TRANS_TYPE | Enumtransactions_TRANS_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.transactions_TRANS_TYPE[]
    notIn?: $Enums.transactions_TRANS_TYPE[]
    not?: NestedEnumtransactions_TRANS_TYPEFilter<$PrismaModel> | $Enums.transactions_TRANS_TYPE
  }

  export type NestedEnumtransactions_TRANS_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transactions_TRANS_TYPE | Enumtransactions_TRANS_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.transactions_TRANS_TYPE[]
    notIn?: $Enums.transactions_TRANS_TYPE[]
    not?: NestedEnumtransactions_TRANS_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.transactions_TRANS_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransactions_TRANS_TYPEFilter<$PrismaModel>
    _max?: NestedEnumtransactions_TRANS_TYPEFilter<$PrismaModel>
  }

  export type usersCreateWithoutCredit_cardsInput = {
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    payment_plan?: payment_planCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    security_log?: security_logCreateNestedManyWithoutUsersInput
    settlements?: settlementsCreateNestedManyWithoutUsersInput
    user_session?: user_sessionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCredit_cardsInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    security_log?: security_logUncheckedCreateNestedManyWithoutUsersInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutUsersInput
    user_session?: user_sessionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCredit_cardsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCredit_cardsInput, usersUncheckedCreateWithoutCredit_cardsInput>
  }

  export type payment_planCreateWithoutCredit_cardsInput = {
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
    users: usersCreateNestedOneWithoutPayment_planInput
  }

  export type payment_planUncheckedCreateWithoutCredit_cardsInput = {
    PLAN_ID?: number
    USER_ID: number
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
  }

  export type payment_planCreateOrConnectWithoutCredit_cardsInput = {
    where: payment_planWhereUniqueInput
    create: XOR<payment_planCreateWithoutCredit_cardsInput, payment_planUncheckedCreateWithoutCredit_cardsInput>
  }

  export type payment_planCreateManyCredit_cardsInputEnvelope = {
    data: payment_planCreateManyCredit_cardsInput | payment_planCreateManyCredit_cardsInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutCredit_cardsInput = {
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
    users?: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutCredit_cardsInput = {
    PAYMENT_ID?: number
    USER_ID?: number | null
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
  }

  export type paymentsCreateOrConnectWithoutCredit_cardsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutCredit_cardsInput, paymentsUncheckedCreateWithoutCredit_cardsInput>
  }

  export type paymentsCreateManyCredit_cardsInputEnvelope = {
    data: paymentsCreateManyCredit_cardsInput | paymentsCreateManyCredit_cardsInput[]
    skipDuplicates?: boolean
  }

  export type settlementsCreateWithoutCredit_cardsInput = {
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
    users?: usersCreateNestedOneWithoutSettlementsInput
  }

  export type settlementsUncheckedCreateWithoutCredit_cardsInput = {
    SET_ID?: number
    USER_ID?: number | null
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
  }

  export type settlementsCreateOrConnectWithoutCredit_cardsInput = {
    where: settlementsWhereUniqueInput
    create: XOR<settlementsCreateWithoutCredit_cardsInput, settlementsUncheckedCreateWithoutCredit_cardsInput>
  }

  export type settlementsCreateManyCredit_cardsInputEnvelope = {
    data: settlementsCreateManyCredit_cardsInput | settlementsCreateManyCredit_cardsInput[]
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutCredit_cardsInput = {
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE
    AMOUNT: Decimal | DecimalJsLike | number | string
    MERCHANT?: string | null
    TRANS_DATE?: Date | string | null
  }

  export type transactionsUncheckedCreateWithoutCredit_cardsInput = {
    TRANS_ID?: number
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE
    AMOUNT: Decimal | DecimalJsLike | number | string
    MERCHANT?: string | null
    TRANS_DATE?: Date | string | null
  }

  export type transactionsCreateOrConnectWithoutCredit_cardsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutCredit_cardsInput, transactionsUncheckedCreateWithoutCredit_cardsInput>
  }

  export type transactionsCreateManyCredit_cardsInputEnvelope = {
    data: transactionsCreateManyCredit_cardsInput | transactionsCreateManyCredit_cardsInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutCredit_cardsInput = {
    update: XOR<usersUpdateWithoutCredit_cardsInput, usersUncheckedUpdateWithoutCredit_cardsInput>
    create: XOR<usersCreateWithoutCredit_cardsInput, usersUncheckedCreateWithoutCredit_cardsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCredit_cardsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCredit_cardsInput, usersUncheckedUpdateWithoutCredit_cardsInput>
  }

  export type usersUpdateWithoutCredit_cardsInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    payment_plan?: payment_planUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    security_log?: security_logUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCredit_cardsInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    payment_plan?: payment_planUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    security_log?: security_logUncheckedUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type payment_planUpsertWithWhereUniqueWithoutCredit_cardsInput = {
    where: payment_planWhereUniqueInput
    update: XOR<payment_planUpdateWithoutCredit_cardsInput, payment_planUncheckedUpdateWithoutCredit_cardsInput>
    create: XOR<payment_planCreateWithoutCredit_cardsInput, payment_planUncheckedCreateWithoutCredit_cardsInput>
  }

  export type payment_planUpdateWithWhereUniqueWithoutCredit_cardsInput = {
    where: payment_planWhereUniqueInput
    data: XOR<payment_planUpdateWithoutCredit_cardsInput, payment_planUncheckedUpdateWithoutCredit_cardsInput>
  }

  export type payment_planUpdateManyWithWhereWithoutCredit_cardsInput = {
    where: payment_planScalarWhereInput
    data: XOR<payment_planUpdateManyMutationInput, payment_planUncheckedUpdateManyWithoutCredit_cardsInput>
  }

  export type payment_planScalarWhereInput = {
    AND?: payment_planScalarWhereInput | payment_planScalarWhereInput[]
    OR?: payment_planScalarWhereInput[]
    NOT?: payment_planScalarWhereInput | payment_planScalarWhereInput[]
    PLAN_ID?: IntFilter<"payment_plan"> | number
    USER_ID?: IntFilter<"payment_plan"> | number
    CARD_ID?: IntFilter<"payment_plan"> | number
    CHOSEN_PLAN?: Enumpayment_plan_CHOSEN_PLANNullableFilter<"payment_plan"> | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFilter<"payment_plan"> | number
    PLAN_START?: DateTimeNullableFilter<"payment_plan"> | Date | string | null
    EST_PLAN_FINISH?: DateTimeNullableFilter<"payment_plan"> | Date | string | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutCredit_cardsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutCredit_cardsInput, paymentsUncheckedUpdateWithoutCredit_cardsInput>
    create: XOR<paymentsCreateWithoutCredit_cardsInput, paymentsUncheckedCreateWithoutCredit_cardsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutCredit_cardsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutCredit_cardsInput, paymentsUncheckedUpdateWithoutCredit_cardsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutCredit_cardsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutCredit_cardsInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    PAYMENT_ID?: IntFilter<"payments"> | number
    USER_ID?: IntNullableFilter<"payments"> | number | null
    CARD_ID?: IntNullableFilter<"payments"> | number | null
    PAID?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: DateTimeNullableFilter<"payments"> | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFilter<"payments"> | $Enums.payments_PAYMENT_METHOD
    STATUS?: Enumpayments_STATUSNullableFilter<"payments"> | $Enums.payments_STATUS | null
  }

  export type settlementsUpsertWithWhereUniqueWithoutCredit_cardsInput = {
    where: settlementsWhereUniqueInput
    update: XOR<settlementsUpdateWithoutCredit_cardsInput, settlementsUncheckedUpdateWithoutCredit_cardsInput>
    create: XOR<settlementsCreateWithoutCredit_cardsInput, settlementsUncheckedCreateWithoutCredit_cardsInput>
  }

  export type settlementsUpdateWithWhereUniqueWithoutCredit_cardsInput = {
    where: settlementsWhereUniqueInput
    data: XOR<settlementsUpdateWithoutCredit_cardsInput, settlementsUncheckedUpdateWithoutCredit_cardsInput>
  }

  export type settlementsUpdateManyWithWhereWithoutCredit_cardsInput = {
    where: settlementsScalarWhereInput
    data: XOR<settlementsUpdateManyMutationInput, settlementsUncheckedUpdateManyWithoutCredit_cardsInput>
  }

  export type settlementsScalarWhereInput = {
    AND?: settlementsScalarWhereInput | settlementsScalarWhereInput[]
    OR?: settlementsScalarWhereInput[]
    NOT?: settlementsScalarWhereInput | settlementsScalarWhereInput[]
    SET_ID?: IntFilter<"settlements"> | number
    USER_ID?: IntNullableFilter<"settlements"> | number | null
    CARD_ID?: IntNullableFilter<"settlements"> | number | null
    ORIGINAL_AMOUNT?: DecimalFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFilter<"settlements"> | Decimal | DecimalJsLike | number | string
    SET_DATE?: DateTimeNullableFilter<"settlements"> | Date | string | null
    STATUS?: Enumsettlements_STATUSNullableFilter<"settlements"> | $Enums.settlements_STATUS | null
  }

  export type transactionsUpsertWithWhereUniqueWithoutCredit_cardsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutCredit_cardsInput, transactionsUncheckedUpdateWithoutCredit_cardsInput>
    create: XOR<transactionsCreateWithoutCredit_cardsInput, transactionsUncheckedCreateWithoutCredit_cardsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutCredit_cardsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutCredit_cardsInput, transactionsUncheckedUpdateWithoutCredit_cardsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutCredit_cardsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutCredit_cardsInput>
  }

  export type transactionsScalarWhereInput = {
    AND?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    OR?: transactionsScalarWhereInput[]
    NOT?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    TRANS_ID?: IntFilter<"transactions"> | number
    CARD_ID?: IntNullableFilter<"transactions"> | number | null
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFilter<"transactions"> | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    MERCHANT?: StringNullableFilter<"transactions"> | string | null
    TRANS_DATE?: DateTimeNullableFilter<"transactions"> | Date | string | null
  }

  export type usersCreateWithoutPayment_planInput = {
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    security_log?: security_logCreateNestedManyWithoutUsersInput
    settlements?: settlementsCreateNestedManyWithoutUsersInput
    user_session?: user_sessionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPayment_planInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    security_log?: security_logUncheckedCreateNestedManyWithoutUsersInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutUsersInput
    user_session?: user_sessionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPayment_planInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPayment_planInput, usersUncheckedCreateWithoutPayment_planInput>
  }

  export type credit_cardsCreateWithoutPayment_planInput = {
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    users: usersCreateNestedOneWithoutCredit_cardsInput
    payments?: paymentsCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsUncheckedCreateWithoutPayment_planInput = {
    CARD_ID?: number
    USER_ID: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    payments?: paymentsUncheckedCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsCreateOrConnectWithoutPayment_planInput = {
    where: credit_cardsWhereUniqueInput
    create: XOR<credit_cardsCreateWithoutPayment_planInput, credit_cardsUncheckedCreateWithoutPayment_planInput>
  }

  export type usersUpsertWithoutPayment_planInput = {
    update: XOR<usersUpdateWithoutPayment_planInput, usersUncheckedUpdateWithoutPayment_planInput>
    create: XOR<usersCreateWithoutPayment_planInput, usersUncheckedCreateWithoutPayment_planInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPayment_planInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPayment_planInput, usersUncheckedUpdateWithoutPayment_planInput>
  }

  export type usersUpdateWithoutPayment_planInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    security_log?: security_logUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPayment_planInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    security_log?: security_logUncheckedUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type credit_cardsUpsertWithoutPayment_planInput = {
    update: XOR<credit_cardsUpdateWithoutPayment_planInput, credit_cardsUncheckedUpdateWithoutPayment_planInput>
    create: XOR<credit_cardsCreateWithoutPayment_planInput, credit_cardsUncheckedCreateWithoutPayment_planInput>
    where?: credit_cardsWhereInput
  }

  export type credit_cardsUpdateToOneWithWhereWithoutPayment_planInput = {
    where?: credit_cardsWhereInput
    data: XOR<credit_cardsUpdateWithoutPayment_planInput, credit_cardsUncheckedUpdateWithoutPayment_planInput>
  }

  export type credit_cardsUpdateWithoutPayment_planInput = {
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    users?: usersUpdateOneRequiredWithoutCredit_cardsNestedInput
    payments?: paymentsUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsUncheckedUpdateWithoutPayment_planInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    payments?: paymentsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCredit_cardsNestedInput
  }

  export type usersCreateWithoutPaymentsInput = {
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planCreateNestedManyWithoutUsersInput
    security_log?: security_logCreateNestedManyWithoutUsersInput
    settlements?: settlementsCreateNestedManyWithoutUsersInput
    user_session?: user_sessionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPaymentsInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsUncheckedCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutUsersInput
    security_log?: security_logUncheckedCreateNestedManyWithoutUsersInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutUsersInput
    user_session?: user_sessionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPaymentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
  }

  export type credit_cardsCreateWithoutPaymentsInput = {
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    users: usersCreateNestedOneWithoutCredit_cardsInput
    payment_plan?: payment_planCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsUncheckedCreateWithoutPaymentsInput = {
    CARD_ID?: number
    USER_ID: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsCreateOrConnectWithoutPaymentsInput = {
    where: credit_cardsWhereUniqueInput
    create: XOR<credit_cardsCreateWithoutPaymentsInput, credit_cardsUncheckedCreateWithoutPaymentsInput>
  }

  export type usersUpsertWithoutPaymentsInput = {
    update: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateWithoutPaymentsInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUpdateManyWithoutUsersNestedInput
    security_log?: security_logUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPaymentsInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUncheckedUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUncheckedUpdateManyWithoutUsersNestedInput
    security_log?: security_logUncheckedUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type credit_cardsUpsertWithoutPaymentsInput = {
    update: XOR<credit_cardsUpdateWithoutPaymentsInput, credit_cardsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<credit_cardsCreateWithoutPaymentsInput, credit_cardsUncheckedCreateWithoutPaymentsInput>
    where?: credit_cardsWhereInput
  }

  export type credit_cardsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: credit_cardsWhereInput
    data: XOR<credit_cardsUpdateWithoutPaymentsInput, credit_cardsUncheckedUpdateWithoutPaymentsInput>
  }

  export type credit_cardsUpdateWithoutPaymentsInput = {
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    users?: usersUpdateOneRequiredWithoutCredit_cardsNestedInput
    payment_plan?: payment_planUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsUncheckedUpdateWithoutPaymentsInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCredit_cardsNestedInput
  }

  export type usersCreateWithoutSecurity_logInput = {
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    settlements?: settlementsCreateNestedManyWithoutUsersInput
    user_session?: user_sessionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSecurity_logInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsUncheckedCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutUsersInput
    user_session?: user_sessionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSecurity_logInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSecurity_logInput, usersUncheckedCreateWithoutSecurity_logInput>
  }

  export type usersUpsertWithoutSecurity_logInput = {
    update: XOR<usersUpdateWithoutSecurity_logInput, usersUncheckedUpdateWithoutSecurity_logInput>
    create: XOR<usersCreateWithoutSecurity_logInput, usersUncheckedCreateWithoutSecurity_logInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSecurity_logInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSecurity_logInput, usersUncheckedUpdateWithoutSecurity_logInput>
  }

  export type usersUpdateWithoutSecurity_logInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSecurity_logInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUncheckedUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type credit_cardsCreateWithoutSettlementsInput = {
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    users: usersCreateNestedOneWithoutCredit_cardsInput
    payment_plan?: payment_planCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsUncheckedCreateWithoutSettlementsInput = {
    CARD_ID?: number
    USER_ID: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsCreateOrConnectWithoutSettlementsInput = {
    where: credit_cardsWhereUniqueInput
    create: XOR<credit_cardsCreateWithoutSettlementsInput, credit_cardsUncheckedCreateWithoutSettlementsInput>
  }

  export type usersCreateWithoutSettlementsInput = {
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    security_log?: security_logCreateNestedManyWithoutUsersInput
    user_session?: user_sessionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSettlementsInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsUncheckedCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    security_log?: security_logUncheckedCreateNestedManyWithoutUsersInput
    user_session?: user_sessionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSettlementsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSettlementsInput, usersUncheckedCreateWithoutSettlementsInput>
  }

  export type credit_cardsUpsertWithoutSettlementsInput = {
    update: XOR<credit_cardsUpdateWithoutSettlementsInput, credit_cardsUncheckedUpdateWithoutSettlementsInput>
    create: XOR<credit_cardsCreateWithoutSettlementsInput, credit_cardsUncheckedCreateWithoutSettlementsInput>
    where?: credit_cardsWhereInput
  }

  export type credit_cardsUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: credit_cardsWhereInput
    data: XOR<credit_cardsUpdateWithoutSettlementsInput, credit_cardsUncheckedUpdateWithoutSettlementsInput>
  }

  export type credit_cardsUpdateWithoutSettlementsInput = {
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    users?: usersUpdateOneRequiredWithoutCredit_cardsNestedInput
    payment_plan?: payment_planUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsUncheckedUpdateWithoutSettlementsInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCredit_cardsNestedInput
  }

  export type usersUpsertWithoutSettlementsInput = {
    update: XOR<usersUpdateWithoutSettlementsInput, usersUncheckedUpdateWithoutSettlementsInput>
    create: XOR<usersCreateWithoutSettlementsInput, usersUncheckedCreateWithoutSettlementsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSettlementsInput, usersUncheckedUpdateWithoutSettlementsInput>
  }

  export type usersUpdateWithoutSettlementsInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    security_log?: security_logUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSettlementsInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUncheckedUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    security_log?: security_logUncheckedUpdateManyWithoutUsersNestedInput
    user_session?: user_sessionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type credit_cardsCreateWithoutTransactionsInput = {
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    users: usersCreateNestedOneWithoutCredit_cardsInput
    payment_plan?: payment_planCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsUncheckedCreateWithoutTransactionsInput = {
    CARD_ID?: number
    USER_ID: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsCreateOrConnectWithoutTransactionsInput = {
    where: credit_cardsWhereUniqueInput
    create: XOR<credit_cardsCreateWithoutTransactionsInput, credit_cardsUncheckedCreateWithoutTransactionsInput>
  }

  export type credit_cardsUpsertWithoutTransactionsInput = {
    update: XOR<credit_cardsUpdateWithoutTransactionsInput, credit_cardsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<credit_cardsCreateWithoutTransactionsInput, credit_cardsUncheckedCreateWithoutTransactionsInput>
    where?: credit_cardsWhereInput
  }

  export type credit_cardsUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: credit_cardsWhereInput
    data: XOR<credit_cardsUpdateWithoutTransactionsInput, credit_cardsUncheckedUpdateWithoutTransactionsInput>
  }

  export type credit_cardsUpdateWithoutTransactionsInput = {
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    users?: usersUpdateOneRequiredWithoutCredit_cardsNestedInput
    payment_plan?: payment_planUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsUncheckedUpdateWithoutTransactionsInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutCredit_cardsNestedInput
  }

  export type usersCreateWithoutUser_sessionInput = {
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    security_log?: security_logCreateNestedManyWithoutUsersInput
    settlements?: settlementsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_sessionInput = {
    USER_ID?: number
    PASS: string
    USER_LNAME: string
    USER_FNAME: string
    STREET?: string | null
    CITY?: string | null
    STATE?: string | null
    ZIP?: string | null
    GENDER?: string | null
    PHONE?: string | null
    EMAIL?: string | null
    credit_cards?: credit_cardsUncheckedCreateNestedManyWithoutUsersInput
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    security_log?: security_logUncheckedCreateNestedManyWithoutUsersInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_sessionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_sessionInput, usersUncheckedCreateWithoutUser_sessionInput>
  }

  export type usersUpsertWithoutUser_sessionInput = {
    update: XOR<usersUpdateWithoutUser_sessionInput, usersUncheckedUpdateWithoutUser_sessionInput>
    create: XOR<usersCreateWithoutUser_sessionInput, usersUncheckedCreateWithoutUser_sessionInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_sessionInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_sessionInput, usersUncheckedUpdateWithoutUser_sessionInput>
  }

  export type usersUpdateWithoutUser_sessionInput = {
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    security_log?: security_logUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_sessionInput = {
    USER_ID?: IntFieldUpdateOperationsInput | number
    PASS?: StringFieldUpdateOperationsInput | string
    USER_LNAME?: StringFieldUpdateOperationsInput | string
    USER_FNAME?: StringFieldUpdateOperationsInput | string
    STREET?: NullableStringFieldUpdateOperationsInput | string | null
    CITY?: NullableStringFieldUpdateOperationsInput | string | null
    STATE?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    credit_cards?: credit_cardsUncheckedUpdateManyWithoutUsersNestedInput
    payment_plan?: payment_planUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    security_log?: security_logUncheckedUpdateManyWithoutUsersNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type credit_cardsCreateWithoutUsersInput = {
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsUncheckedCreateWithoutUsersInput = {
    CARD_ID?: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedCreateNestedManyWithoutCredit_cardsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCredit_cardsInput
    settlements?: settlementsUncheckedCreateNestedManyWithoutCredit_cardsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCredit_cardsInput
  }

  export type credit_cardsCreateOrConnectWithoutUsersInput = {
    where: credit_cardsWhereUniqueInput
    create: XOR<credit_cardsCreateWithoutUsersInput, credit_cardsUncheckedCreateWithoutUsersInput>
  }

  export type credit_cardsCreateManyUsersInputEnvelope = {
    data: credit_cardsCreateManyUsersInput | credit_cardsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type payment_planCreateWithoutUsersInput = {
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
    credit_cards: credit_cardsCreateNestedOneWithoutPayment_planInput
  }

  export type payment_planUncheckedCreateWithoutUsersInput = {
    PLAN_ID?: number
    CARD_ID: number
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
  }

  export type payment_planCreateOrConnectWithoutUsersInput = {
    where: payment_planWhereUniqueInput
    create: XOR<payment_planCreateWithoutUsersInput, payment_planUncheckedCreateWithoutUsersInput>
  }

  export type payment_planCreateManyUsersInputEnvelope = {
    data: payment_planCreateManyUsersInput | payment_planCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutUsersInput = {
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
    credit_cards?: credit_cardsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutUsersInput = {
    PAYMENT_ID?: number
    CARD_ID?: number | null
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
  }

  export type paymentsCreateOrConnectWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsCreateManyUsersInputEnvelope = {
    data: paymentsCreateManyUsersInput | paymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type security_logCreateWithoutUsersInput = {
    ACTION: string
    LOG_TIME?: Date | string | null
  }

  export type security_logUncheckedCreateWithoutUsersInput = {
    LOG_ID?: number
    ACTION: string
    LOG_TIME?: Date | string | null
  }

  export type security_logCreateOrConnectWithoutUsersInput = {
    where: security_logWhereUniqueInput
    create: XOR<security_logCreateWithoutUsersInput, security_logUncheckedCreateWithoutUsersInput>
  }

  export type security_logCreateManyUsersInputEnvelope = {
    data: security_logCreateManyUsersInput | security_logCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type settlementsCreateWithoutUsersInput = {
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
    credit_cards?: credit_cardsCreateNestedOneWithoutSettlementsInput
  }

  export type settlementsUncheckedCreateWithoutUsersInput = {
    SET_ID?: number
    CARD_ID?: number | null
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
  }

  export type settlementsCreateOrConnectWithoutUsersInput = {
    where: settlementsWhereUniqueInput
    create: XOR<settlementsCreateWithoutUsersInput, settlementsUncheckedCreateWithoutUsersInput>
  }

  export type settlementsCreateManyUsersInputEnvelope = {
    data: settlementsCreateManyUsersInput | settlementsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_sessionCreateWithoutUsersInput = {
    SESSION_TOKEN: string
    EXPIRES: Date | string
  }

  export type user_sessionUncheckedCreateWithoutUsersInput = {
    SESSION_ID?: number
    SESSION_TOKEN: string
    EXPIRES: Date | string
  }

  export type user_sessionCreateOrConnectWithoutUsersInput = {
    where: user_sessionWhereUniqueInput
    create: XOR<user_sessionCreateWithoutUsersInput, user_sessionUncheckedCreateWithoutUsersInput>
  }

  export type user_sessionCreateManyUsersInputEnvelope = {
    data: user_sessionCreateManyUsersInput | user_sessionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type credit_cardsUpsertWithWhereUniqueWithoutUsersInput = {
    where: credit_cardsWhereUniqueInput
    update: XOR<credit_cardsUpdateWithoutUsersInput, credit_cardsUncheckedUpdateWithoutUsersInput>
    create: XOR<credit_cardsCreateWithoutUsersInput, credit_cardsUncheckedCreateWithoutUsersInput>
  }

  export type credit_cardsUpdateWithWhereUniqueWithoutUsersInput = {
    where: credit_cardsWhereUniqueInput
    data: XOR<credit_cardsUpdateWithoutUsersInput, credit_cardsUncheckedUpdateWithoutUsersInput>
  }

  export type credit_cardsUpdateManyWithWhereWithoutUsersInput = {
    where: credit_cardsScalarWhereInput
    data: XOR<credit_cardsUpdateManyMutationInput, credit_cardsUncheckedUpdateManyWithoutUsersInput>
  }

  export type credit_cardsScalarWhereInput = {
    AND?: credit_cardsScalarWhereInput | credit_cardsScalarWhereInput[]
    OR?: credit_cardsScalarWhereInput[]
    NOT?: credit_cardsScalarWhereInput | credit_cardsScalarWhereInput[]
    CARD_ID?: IntFilter<"credit_cards"> | number
    USER_ID?: IntFilter<"credit_cards"> | number
    CARD_NUMBER?: StringFilter<"credit_cards"> | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFilter<"credit_cards"> | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string
    BALANCE?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFilter<"credit_cards"> | Date | string
    STATUS?: Enumcredit_cards_STATUSNullableFilter<"credit_cards"> | $Enums.credit_cards_STATUS | null
  }

  export type payment_planUpsertWithWhereUniqueWithoutUsersInput = {
    where: payment_planWhereUniqueInput
    update: XOR<payment_planUpdateWithoutUsersInput, payment_planUncheckedUpdateWithoutUsersInput>
    create: XOR<payment_planCreateWithoutUsersInput, payment_planUncheckedCreateWithoutUsersInput>
  }

  export type payment_planUpdateWithWhereUniqueWithoutUsersInput = {
    where: payment_planWhereUniqueInput
    data: XOR<payment_planUpdateWithoutUsersInput, payment_planUncheckedUpdateWithoutUsersInput>
  }

  export type payment_planUpdateManyWithWhereWithoutUsersInput = {
    where: payment_planScalarWhereInput
    data: XOR<payment_planUpdateManyMutationInput, payment_planUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
  }

  export type paymentsUpdateManyWithWhereWithoutUsersInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type security_logUpsertWithWhereUniqueWithoutUsersInput = {
    where: security_logWhereUniqueInput
    update: XOR<security_logUpdateWithoutUsersInput, security_logUncheckedUpdateWithoutUsersInput>
    create: XOR<security_logCreateWithoutUsersInput, security_logUncheckedCreateWithoutUsersInput>
  }

  export type security_logUpdateWithWhereUniqueWithoutUsersInput = {
    where: security_logWhereUniqueInput
    data: XOR<security_logUpdateWithoutUsersInput, security_logUncheckedUpdateWithoutUsersInput>
  }

  export type security_logUpdateManyWithWhereWithoutUsersInput = {
    where: security_logScalarWhereInput
    data: XOR<security_logUpdateManyMutationInput, security_logUncheckedUpdateManyWithoutUsersInput>
  }

  export type security_logScalarWhereInput = {
    AND?: security_logScalarWhereInput | security_logScalarWhereInput[]
    OR?: security_logScalarWhereInput[]
    NOT?: security_logScalarWhereInput | security_logScalarWhereInput[]
    LOG_ID?: IntFilter<"security_log"> | number
    USER_ID?: IntNullableFilter<"security_log"> | number | null
    ACTION?: StringFilter<"security_log"> | string
    LOG_TIME?: DateTimeNullableFilter<"security_log"> | Date | string | null
  }

  export type settlementsUpsertWithWhereUniqueWithoutUsersInput = {
    where: settlementsWhereUniqueInput
    update: XOR<settlementsUpdateWithoutUsersInput, settlementsUncheckedUpdateWithoutUsersInput>
    create: XOR<settlementsCreateWithoutUsersInput, settlementsUncheckedCreateWithoutUsersInput>
  }

  export type settlementsUpdateWithWhereUniqueWithoutUsersInput = {
    where: settlementsWhereUniqueInput
    data: XOR<settlementsUpdateWithoutUsersInput, settlementsUncheckedUpdateWithoutUsersInput>
  }

  export type settlementsUpdateManyWithWhereWithoutUsersInput = {
    where: settlementsScalarWhereInput
    data: XOR<settlementsUpdateManyMutationInput, settlementsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_sessionUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_sessionWhereUniqueInput
    update: XOR<user_sessionUpdateWithoutUsersInput, user_sessionUncheckedUpdateWithoutUsersInput>
    create: XOR<user_sessionCreateWithoutUsersInput, user_sessionUncheckedCreateWithoutUsersInput>
  }

  export type user_sessionUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_sessionWhereUniqueInput
    data: XOR<user_sessionUpdateWithoutUsersInput, user_sessionUncheckedUpdateWithoutUsersInput>
  }

  export type user_sessionUpdateManyWithWhereWithoutUsersInput = {
    where: user_sessionScalarWhereInput
    data: XOR<user_sessionUpdateManyMutationInput, user_sessionUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_sessionScalarWhereInput = {
    AND?: user_sessionScalarWhereInput | user_sessionScalarWhereInput[]
    OR?: user_sessionScalarWhereInput[]
    NOT?: user_sessionScalarWhereInput | user_sessionScalarWhereInput[]
    SESSION_ID?: IntFilter<"user_session"> | number
    USER_ID?: IntNullableFilter<"user_session"> | number | null
    SESSION_TOKEN?: StringFilter<"user_session"> | string
    EXPIRES?: DateTimeFilter<"user_session"> | Date | string
  }

  export type debtCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    name: string
    balance: Decimal | DecimalJsLike | number | string
    currentBalance: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    minimumPayment: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    extraPayment?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debtUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    name: string
    balance: Decimal | DecimalJsLike | number | string
    currentBalance: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    minimumPayment: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    extraPayment?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debtCreateOrConnectWithoutPaymentsInput = {
    where: debtWhereUniqueInput
    create: XOR<debtCreateWithoutPaymentsInput, debtUncheckedCreateWithoutPaymentsInput>
  }

  export type debtUpsertWithoutPaymentsInput = {
    update: XOR<debtUpdateWithoutPaymentsInput, debtUncheckedUpdateWithoutPaymentsInput>
    create: XOR<debtCreateWithoutPaymentsInput, debtUncheckedCreateWithoutPaymentsInput>
    where?: debtWhereInput
  }

  export type debtUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: debtWhereInput
    data: XOR<debtUpdateWithoutPaymentsInput, debtUncheckedUpdateWithoutPaymentsInput>
  }

  export type debtUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extraPayment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debtUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    extraPayment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debt_paymentCreateWithoutDebtInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debt_paymentUncheckedCreateWithoutDebtInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debt_paymentCreateOrConnectWithoutDebtInput = {
    where: debt_paymentWhereUniqueInput
    create: XOR<debt_paymentCreateWithoutDebtInput, debt_paymentUncheckedCreateWithoutDebtInput>
  }

  export type debt_paymentCreateManyDebtInputEnvelope = {
    data: debt_paymentCreateManyDebtInput | debt_paymentCreateManyDebtInput[]
    skipDuplicates?: boolean
  }

  export type debt_paymentUpsertWithWhereUniqueWithoutDebtInput = {
    where: debt_paymentWhereUniqueInput
    update: XOR<debt_paymentUpdateWithoutDebtInput, debt_paymentUncheckedUpdateWithoutDebtInput>
    create: XOR<debt_paymentCreateWithoutDebtInput, debt_paymentUncheckedCreateWithoutDebtInput>
  }

  export type debt_paymentUpdateWithWhereUniqueWithoutDebtInput = {
    where: debt_paymentWhereUniqueInput
    data: XOR<debt_paymentUpdateWithoutDebtInput, debt_paymentUncheckedUpdateWithoutDebtInput>
  }

  export type debt_paymentUpdateManyWithWhereWithoutDebtInput = {
    where: debt_paymentScalarWhereInput
    data: XOR<debt_paymentUpdateManyMutationInput, debt_paymentUncheckedUpdateManyWithoutDebtInput>
  }

  export type debt_paymentScalarWhereInput = {
    AND?: debt_paymentScalarWhereInput | debt_paymentScalarWhereInput[]
    OR?: debt_paymentScalarWhereInput[]
    NOT?: debt_paymentScalarWhereInput | debt_paymentScalarWhereInput[]
    id?: StringFilter<"debt_payment"> | string
    debtId?: StringFilter<"debt_payment"> | string
    userId?: StringFilter<"debt_payment"> | string
    amount?: DecimalFilter<"debt_payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"debt_payment"> | Date | string
    notes?: StringNullableFilter<"debt_payment"> | string | null
    createdAt?: DateTimeFilter<"debt_payment"> | Date | string
    updatedAt?: DateTimeFilter<"debt_payment"> | Date | string
  }

  export type payment_planCreateManyCredit_cardsInput = {
    PLAN_ID?: number
    USER_ID: number
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
  }

  export type paymentsCreateManyCredit_cardsInput = {
    PAYMENT_ID?: number
    USER_ID?: number | null
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
  }

  export type settlementsCreateManyCredit_cardsInput = {
    SET_ID?: number
    USER_ID?: number | null
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
  }

  export type transactionsCreateManyCredit_cardsInput = {
    TRANS_ID?: number
    TRANS_TYPE: $Enums.transactions_TRANS_TYPE
    AMOUNT: Decimal | DecimalJsLike | number | string
    MERCHANT?: string | null
    TRANS_DATE?: Date | string | null
  }

  export type payment_planUpdateWithoutCredit_cardsInput = {
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutPayment_planNestedInput
  }

  export type payment_planUncheckedUpdateWithoutCredit_cardsInput = {
    PLAN_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_planUncheckedUpdateManyWithoutCredit_cardsInput = {
    PLAN_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: IntFieldUpdateOperationsInput | number
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUpdateWithoutCredit_cardsInput = {
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
    users?: usersUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutCredit_cardsInput = {
    PAYMENT_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
  }

  export type paymentsUncheckedUpdateManyWithoutCredit_cardsInput = {
    PAYMENT_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
  }

  export type settlementsUpdateWithoutCredit_cardsInput = {
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
    users?: usersUpdateOneWithoutSettlementsNestedInput
  }

  export type settlementsUncheckedUpdateWithoutCredit_cardsInput = {
    SET_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
  }

  export type settlementsUncheckedUpdateManyWithoutCredit_cardsInput = {
    SET_ID?: IntFieldUpdateOperationsInput | number
    USER_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
  }

  export type transactionsUpdateWithoutCredit_cardsInput = {
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    MERCHANT?: NullableStringFieldUpdateOperationsInput | string | null
    TRANS_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionsUncheckedUpdateWithoutCredit_cardsInput = {
    TRANS_ID?: IntFieldUpdateOperationsInput | number
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    MERCHANT?: NullableStringFieldUpdateOperationsInput | string | null
    TRANS_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionsUncheckedUpdateManyWithoutCredit_cardsInput = {
    TRANS_ID?: IntFieldUpdateOperationsInput | number
    TRANS_TYPE?: Enumtransactions_TRANS_TYPEFieldUpdateOperationsInput | $Enums.transactions_TRANS_TYPE
    AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    MERCHANT?: NullableStringFieldUpdateOperationsInput | string | null
    TRANS_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type credit_cardsCreateManyUsersInput = {
    CARD_ID?: number
    CARD_NUMBER: string
    CARD_TYPE: $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT: Decimal | DecimalJsLike | number | string
    BALANCE?: Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: Decimal | DecimalJsLike | number | string | null
    DUE_DATE: Date | string
    STATUS?: $Enums.credit_cards_STATUS | null
  }

  export type payment_planCreateManyUsersInput = {
    PLAN_ID?: number
    CARD_ID: number
    CHOSEN_PLAN?: $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS: number
    PLAN_START?: Date | string | null
    EST_PLAN_FINISH?: Date | string | null
  }

  export type paymentsCreateManyUsersInput = {
    PAYMENT_ID?: number
    CARD_ID?: number | null
    PAID: Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: Date | string | null
    PAYMENT_METHOD: $Enums.payments_PAYMENT_METHOD
    STATUS?: $Enums.payments_STATUS | null
  }

  export type security_logCreateManyUsersInput = {
    LOG_ID?: number
    ACTION: string
    LOG_TIME?: Date | string | null
  }

  export type settlementsCreateManyUsersInput = {
    SET_ID?: number
    CARD_ID?: number | null
    ORIGINAL_AMOUNT: Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT: Decimal | DecimalJsLike | number | string
    SET_DATE?: Date | string | null
    STATUS?: $Enums.settlements_STATUS | null
  }

  export type user_sessionCreateManyUsersInput = {
    SESSION_ID?: number
    SESSION_TOKEN: string
    EXPIRES: Date | string
  }

  export type credit_cardsUpdateWithoutUsersInput = {
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsUncheckedUpdateWithoutUsersInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
    payment_plan?: payment_planUncheckedUpdateManyWithoutCredit_cardsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    settlements?: settlementsUncheckedUpdateManyWithoutCredit_cardsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCredit_cardsNestedInput
  }

  export type credit_cardsUncheckedUpdateManyWithoutUsersInput = {
    CARD_ID?: IntFieldUpdateOperationsInput | number
    CARD_NUMBER?: StringFieldUpdateOperationsInput | string
    CARD_TYPE?: Enumcredit_cards_CARD_TYPEFieldUpdateOperationsInput | $Enums.credit_cards_CARD_TYPE
    CREDIT_LIMIT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BALANCE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    INTEREST_RATE?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DUE_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    STATUS?: NullableEnumcredit_cards_STATUSFieldUpdateOperationsInput | $Enums.credit_cards_STATUS | null
  }

  export type payment_planUpdateWithoutUsersInput = {
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credit_cards?: credit_cardsUpdateOneRequiredWithoutPayment_planNestedInput
  }

  export type payment_planUncheckedUpdateWithoutUsersInput = {
    PLAN_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: IntFieldUpdateOperationsInput | number
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_planUncheckedUpdateManyWithoutUsersInput = {
    PLAN_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: IntFieldUpdateOperationsInput | number
    CHOSEN_PLAN?: NullableEnumpayment_plan_CHOSEN_PLANFieldUpdateOperationsInput | $Enums.payment_plan_CHOSEN_PLAN | null
    PROGRESS?: IntFieldUpdateOperationsInput | number
    PLAN_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EST_PLAN_FINISH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUpdateWithoutUsersInput = {
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
    credit_cards?: credit_cardsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutUsersInput = {
    PAYMENT_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
  }

  export type paymentsUncheckedUpdateManyWithoutUsersInput = {
    PAYMENT_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    PAID?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PAYMENT_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PAYMENT_METHOD?: Enumpayments_PAYMENT_METHODFieldUpdateOperationsInput | $Enums.payments_PAYMENT_METHOD
    STATUS?: NullableEnumpayments_STATUSFieldUpdateOperationsInput | $Enums.payments_STATUS | null
  }

  export type security_logUpdateWithoutUsersInput = {
    ACTION?: StringFieldUpdateOperationsInput | string
    LOG_TIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type security_logUncheckedUpdateWithoutUsersInput = {
    LOG_ID?: IntFieldUpdateOperationsInput | number
    ACTION?: StringFieldUpdateOperationsInput | string
    LOG_TIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type security_logUncheckedUpdateManyWithoutUsersInput = {
    LOG_ID?: IntFieldUpdateOperationsInput | number
    ACTION?: StringFieldUpdateOperationsInput | string
    LOG_TIME?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settlementsUpdateWithoutUsersInput = {
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
    credit_cards?: credit_cardsUpdateOneWithoutSettlementsNestedInput
  }

  export type settlementsUncheckedUpdateWithoutUsersInput = {
    SET_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
  }

  export type settlementsUncheckedUpdateManyWithoutUsersInput = {
    SET_ID?: IntFieldUpdateOperationsInput | number
    CARD_ID?: NullableIntFieldUpdateOperationsInput | number | null
    ORIGINAL_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SETTLED_AMOUNT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SET_DATE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    STATUS?: NullableEnumsettlements_STATUSFieldUpdateOperationsInput | $Enums.settlements_STATUS | null
  }

  export type user_sessionUpdateWithoutUsersInput = {
    SESSION_TOKEN?: StringFieldUpdateOperationsInput | string
    EXPIRES?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionUncheckedUpdateWithoutUsersInput = {
    SESSION_ID?: IntFieldUpdateOperationsInput | number
    SESSION_TOKEN?: StringFieldUpdateOperationsInput | string
    EXPIRES?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionUncheckedUpdateManyWithoutUsersInput = {
    SESSION_ID?: IntFieldUpdateOperationsInput | number
    SESSION_TOKEN?: StringFieldUpdateOperationsInput | string
    EXPIRES?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debt_paymentCreateManyDebtInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type debt_paymentUpdateWithoutDebtInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debt_paymentUncheckedUpdateWithoutDebtInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type debt_paymentUncheckedUpdateManyWithoutDebtInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}